<!DOCTYPE html>
<html lang="pl">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Notatki z frontendu</title>
	<link href="style.css" rel="stylesheet" type="text/css">
</head>

<body class="body">
	<header class="header">
		<nav>
			<a class="header-link" href="index.html">Strona główna</a>
			<a class="header-link" href="nauka-html.html">Nauka HTML</a>
			<a class="header-link" href="nauka-css.html">Nauka CSS</a>
			<a class="header-link" href="nauka-js.html">Nauka JavaScriptu</a>
			<a class="header-link" href="nauka-varia.html">Nauka - varia</a>
		</nav>

	</header>
	<main class="main">
		<header id="top">
			<h1 class="main-header">Nauka CSS-a</h1>

		</header>
		<section class="section">
			<h2 class="section-header">CSS - tydzień 2</h2>
			<article class="article">
				<h3 class="article-header">CSS - podstawowe informacje i selektory, kolory</h3>
				<p class="paragraph"><b>CSS – Cascading style sheets</b> – odpowiada za prezentację, wygląd treści.
					Każdy język ma swoją składnię, w przypadku CSS są to reguły, mające następującą budowę: <br>
					selektor { <br>
					właściwość: wartość; <br>
					}
				</p>
				<p class="paragraph">Style co do zasady definiuje się w osobnym pliku o rozszerzeniu .css, ale można je
					też zdefiniować w
					pliku html w sekcji "head" poprzez dodanie znacznika "style", gdzie definiujemy właściwości
					poszczególnych elementów, odnosząc się do nich za pomocą selektorów, którymi mogą być nazwy tych
					elementów (np. h1, p), np.: <br>
					p { <br>
					color: green; <br>
					}
				</p>
				<p class="paragraph">Sposobów zapisu kolorów jest kilka, np. angielska nazwa, zapis heksadecymalny,
					czyli w systemie
					szestnastkowym - #xxyyzz, gdzie xx to kanał czerwony, yy to kanał zielony, a zz to kanał niebieski.
					Style określa się jednak najczęściej w zewnętrznym arkuszu stylów, a w samym pliku html zawiera się
					do niego odnośnik poprzez odpowiednia frazę – znacznik "link" o odpowiedniej składni.
					Kolejną własnością, obok koloru, jest tło. Można je określić dla całej strony wskazując jako
					selektor "body", czyli np.: <br>
					body { <br>
					background: lightyellow; <br>
					}
				</p>
				<p class="paragraph">
					Możemy zaprojektować paletę kolorystyczną naszej strony posiłkując się
					<a class="link" href="https://coolors.co">generatorem coolors</a>
				</p>
			</article>
		</section>
		<section class="section">
			<h2 class="section-header">CSS - tydzień 3</h2>
			<article class="article">
				<h3 class="article-header">Stylowanie w oparciu o atrybuty element, id i klasa</h3>
				<p class="paragraph">
					Oprócz tego, że style można zamieścić w ramach znacznika style w sekcji "head" lub w pliku
					zewnętrznym, można je też zastosować używając atrybutu "style" i przypisując go do konkretnego
					znacznika, np. section, h1, p, etc. wg schematu: <br>
					znacznik style="color:yellow; background:#ffffff;" treść /znacznik <br>
					Styl przy znaczniku z wykorzystaniem atrybutu "style" nazywamy stylem inline, liniowym. Znajduje on
					zastosowanie jedynie do tego konkretnego znacznika, przy którym atrybut ten został wpisany. <br>
					Aplikowanie stylów w ten sposób nie ma jednak większego sensu, bo robi się bałagan - kod staje się
					nieczytelny i trudny do modyfikacji. I tutaj właśnie w grę wchodzą tzw. prawdziwe selektory -
					wcześniej stylowaliśmy odnosząc się do elementów, natomiast najlepiej to robić w oparciu o
					identyfikatory i klasy: #id i .class. Zwłaszcza klasy, które dodaje się do znaczników wg schematu:
					<br>
					znacznik class="name" treść /znacznik <br>
					Atrybut .class dodajemy w html przy danych tagach/znacznikach (pozwala na pogrupowanie elementów),
					natomiast przekłada się on na stylowanie i cssy. Nazwę, którą nadajemy danej klasie, tworzymy wg
					schematu kebab-case. Aby ostylować elementy, które mają przypisaną daną klasę, odnosimy się do nich
					w pliku ze stylami w następujący sposób: <br>
					.name { <br>
					właściwość: wartość; <br>
					} <br>
					.(kropka) - to selektor klasy
				</p>
				<p class="paragraph">
					Do stylowania elementów można wykorzystać również id, które wcześniej nadaliśmy tagom po to, by
					wykorzystać je jako kotwicę służącą do przenoszenia się w ramach dokumentu do konkretnej sekcji.
					Identyfikator nadaje się elementom i wykorzystuje do stylowania wg następującego schematu: <br>
					znacznik id="name" treść /znacznik <br>
					#name { <br>
					właściwość: wartość; <br>
					} <br>
					# (hash) - to selektor id <br>
					Na danej stronie dokumentu może znajdować się tylko jedno id o danej konkretnej wartości, przypisane
					do jednego konkretnego elementu.
				</p>
				<p class="paragraph">
					Selektory można łączyć, czyli do danego znacznika może byc przypisane konkretne id i określona
					klasa. <br>
					Jeśli chcemy ostylować wg określonego wzoru wszystkie linki, które znajdują się w obszarze nawigacji
					"nav", tak by stylowanie odróżniało je od pozostałych linków występujących w treści dokumentu.
					Elementy o znaczniku "a" są zatem zagnieżdżone w znaczniku "nav", chcemy więc ostylować elementy
					znajdujące się w innym elemencie. Odnosimy się do nich w pliku z cssami wpisując po sobie elementy
					"nav" i po spacji "a" wg wzoru: <br>
					nav a { <br>
					własność: wartość1; <br>
					} <br>
					a { <br>
					własność: wartość2; <br>
					} <br>
					Przy takim zapisie style nie zaaplikują się do samego znacznika "nav", ale do zawartych w nim
					elementów "a", gdzie dana własnośc będzie miała wartość1. Natomiast pozostałe elementy "a", które
					nie są zagnieżdżone w "nav" przyjmą wartość2 dla tej własności. Odnosząc się do elementów "a"
					zawartych w "nav" nie musimy więc podawać dokładnej ścieżki body>header>nav, wystarczy podanie
					bezpośredniego rodzica, czyli "nav". Nie musi to być również bezpośredni rodzic - w tym przypadku
					ten sam efekt osiągniemy wpisując ścieżkę header>a.
				</p>
			</article>
			<article class="article">
				<h3 class="article-header">!important i specyficzność w CSS</h3>
				<p class="paragraph">
					!important to zmora, jeśli chodzi o stylowanie. Nie powinno się tego używać, ponieważ !important
					dopisany przy wartości dla danej własności opisującej określony element sprawia, że styl, przy
					którym został on dodany nadpisuje wszystkie inne style, które zostały zdefiniowane dla danego
					elementu. Opierając się na wcześniejszym przykładzie rozróżnienia stylów linków zagnieżdżonych w
					znaczniku "nav" oraz linków znajdujących się poza tym znacznikiem w treści dokumentu, dodanie
					"!important" przy własności zdefiniowanej dla linków niezagnieżdżonych sprawia, że wszystkie linki,
					zagnieżdżone i niezagnieżdżone, zostaną ostylowanie zgodnie z tym stylem. Przykład takiego zapisu:
					<br>
					nav a { <br>
					własność: wartość1; <br>
					} <br>
					a { <br>
					własność: wartość2 !important; <br>
					} <br>
					Wstawienie importanta w jakimś miejscu może więc sprawić, że stylowanie całej strony się posypie.
					Zatem jeśli nie musimy i zastosowanie importanta nie jest naprawdę celowe w danym przypadku, to go
					nie używajmy.
				</p>
				<p class="paragraph">
					Co w sytuacji, gdy do danego elementu mamy zdefiniowane stylowanie zarówno w pliku css, jak i przy
					danym znaczniku jako inline, tak jak na poniższym przykładzie? <br>
					W pliku CSS mamy zapis: <br>
					#name { <br>
					color: red; <br>
					} <br>
					Natomiast w kodzie html przy danym elemencie mamy wstawiony inline: <br>
					span id="name" style="color: yellow" treść /span <br>
					Dla treści elementu span o id=name mamy więc zdefiniowany w pliku css kolor czerwony, natomiast w
					stylu liniowym kolor żółty. Przeglądarka zastosuje tutaj styl zdefiniowany w inline, czyli treść
					będzie miała kolor żółty. <br>
					Jest to przykład występowania specyficzności w CSS, czyli zasad ważności sposobów zastosowania
					stylów w sytuacji, gdy są one w konflikcie. Specificity to zatem zasada, która określa który
					selektor ma pierwszeństwo w przypadku, kiedy wiele z nich ustawia te same reguły CSS dla tego samego
					znacznika HTML. Kolejność ta została zwizualizowana na poniższym obrazku.
				</p>
				<img class="image" src="specificity-rules.JPG"
					alt="Obrazek przedstawiający kolejność zastosowania selektorów: important, inline, id, klasa, element." />
				<p class="paragraph">
					Zastosowanie ma zatem następująca kolejność wg pierwszeństwa obowiązywania reguł wprowadzonych przez
					selektory: important, inline, id, klasa, element. Przy czym dwa pierwsze, important i inline, są
					stosowane rzadko, dlatego zostały ujęte w nawiasie. <br>
					Przykładowo, jeśli mamy zdefiniowane dwie reguły css dla znacznika h1 w taki sposób jak poniżej,
					czyli w jednej z nich jako selektor podajemy sam pojedynczy znacznik h1, natomiast w drugiej
					uwzględniamy zagnieżdżenie tego znacznika h1 w elemencie body (jako selektor podajemy dwa elementy -
					dziecko i rodzica), to w opierając się na zasadach specificity, zastosowanie będzie miała reguła CSS
					zdefiniowana w oparciu o selektor z dwoma elementami (bo dwa elementy to więcej niż jeden element).
					<br>
					h1 { <br>
					color: red; <br>
					} <br>
					body h1 { <br>
					color: yellow; <br>
					} <br>
					Nagłówek będzie zatem żółty, ponieważ reguła CSS definiująca ten styl <b>ma wyższą
						specyficzność</b>. Poniżej znajduje się obrazek przedstawiający wizualizację tego
					przykładu.
				</p>
				<img class="image" src="specificity-example1.JPG"
					alt="Obrazek przedstawiający pierwszeństwo zastosowania reguł CSS, gdy jedna jest zdefiniowana w oparciu o selektor jednoelementowy, a druga dwuelementowy." />
				<p class="paragraph">
					To, która z reguł CSS będzie miała zastosowane jest również widoczne w devtools w przeglądarce -
					styl, który został nadpisany jest przekreślony. Przekreślone są również zwykle domyślne style
					przeglądarki, gdy są nadpisywane przez nas. W tym przypadku nie są przekreślone, bo taka własność
					nie została zdefiniowana w przeglądarce (zadziałoby się tak np. w przypadku stylów zdefiniowanych
					dla
					linków). Poniżej zrzut ekranu z devtools dla omawianego przypadku.
				</p>
				<img class="image" src="specificity-example-devtools.jpg"
					alt="Zrzut ekranu z devtools przedstawiający pierwszeństwo zastosowania reguł CSS, gdy jedna jest zdefiniowana w oparciu o selektor jednoelementowy, a druga dwuelementowy." />
				<p class="paragraph">
					Devtools pozwala też na dodanie w zakładce elements do znacznika body atrybutu "contenteditable",
					poprzez
					kliknięcie prawym przyciskiem i wybór opcji add atribute. Po dodaniu atrybutu można na żywo edytować
					stronę z
					poziomu jej widoku, a nie narzędzi w devtools.
				</p>

				<p class="paragraph">
					Kolejnym przykładem zastosowania reguł specyficzności css jest sytuacja, gdy do danego nagłówka
					zostały użyte reguły css, z których jedna styluje go w oparciu o selektor składający się z trzech
					elementów, natomiast druga używa selektora w postaci id. <br>
					html body h1 { <br>
					color: yellow; <br>
					} <br>
					#main-header { <br>
					color: red; <br>
					} <br>
					Wyższą specyficzność będzie miała tu reguła definiująca kolor czerwony. Mimo tego, że kolor żółty
					opiera sie na selektorze składającym się z trzech elementów, a kolor czerwony określany jest dla
					selektora składającego sie z jednego id, to id ma większą wagę i pierwszeństwo w zasadach
					specyficzności. Wizualizację tego przykładu zawiera poniższy obrazek.
				</p>
				<img class="image" src="specificity-example2.JPG"
					alt="Obrazek przedstawiający pierwszeństwo zastosowania reguł CSS, gdy jedna jest zdefiniowana w oparciu o selektor trójelementowy, a druga selektor id." />
				<p class="paragraph">
					Na kolejnym przykładzie mamy sytuację, gdy jeden ze stylów zdefiniowany jest w oparciu o id i trzy
					elementy, natomiast drugi w oparciu o id, klasę i jeden element. Wyższą specyficzność będzie miała
					reguła CSS bazująca na id, klasie i jednym elemencie, ponieważ zawiera więcej selektorów o wyższej
					wadze - id i klasa (2). Można to też przeczytać jako całe liczby i w ten sposób 111 > 103, a zatem
					nagłówek będzie miał kolor czerwony. Poniżej zapis kodu i obrazek, który ilustruje ten przykład.<br>
					(Selektor id piszemy łącznie z selektorem elementu, do którego się odnosi, bez spacji. To samo w
					przypadku selektora klasy, który odnosi się do danego elementu).
					<br>
					html body h1#main-header { <br>
					color: yellow; <br>
					} <br>
					body .section #main-header { <br>
					color: red; <br>
					}
				</p>
				<img class="image" src="specificity-example3.JPG"
					alt="Obrazek przedstawiający pierwszeństwo zastosowania reguł CSS, gdy jedna jest zdefiniowana w oparciu o id i trzy elementy, a druga w oparciu o selektor id, klasę i jeden element." />
				<p class="paragraph">
					<strong>Jeśli specyficzność jest równa, to pierwszeństwo ma selektor znajdujący się "bliżej"
						elementu.</strong> <br>
					Przykładowo w jednym pliku style.css mamy zdefiniowane dwie reguły składające się z tych samych
					selektorów,
					lecz każda z tych reguł styluje dany element w inny sposób. I jedna z reguł znajduje się pod drugą w
					treści pliku, przy czym reguła definiująca kolor czerwony znajduje się wyżej niż reguła stylująca
					kolor niebieski. Zastosowanie będzie miała tu reguła stylująca kolor niebieski, czyli ta, która jest
					niżej, ponieważ znajduje się ona bliżej stylowanego elementu.<br>
					body section#main h1.heading { <br>
					color: red; <br>
					} <br>
					body section#main h1.heading { <br>
					color: blue; <br>
					}
				</p>
				<p class="paragraph">
					Aby unaocznić sobie, na czym polega ta bliskość, wyobrażamy sobie, że style zdefiniowane w pliku
					style.css są umieszczone w pliku HTML w miejscu, gdzie znajduje się odniesienie do pliku css. Na
					przykładzie zobrazowanym poniżej element header ma przypisaną klasę "styl1", w oparciu o którą
					został ostylowany w pliku css, gdzie dla tej samej reguły określono dwa różne style. Zastosowany
					zostanie styl definiujący kolor niebieski, ponieważ jest umieszczony niżej, a tym samym fizycznie
					znajduje się bliżej elementu header.
				</p>
				<img class="image" src="specificity-example4.JPG"
					alt="Zrzut ekranu przedstawiający, na czym polega bliskość stylowanego elementu reguły znajdującej sie niżej w pliku." />
				<p class="paragraph">
					Analogicznie wygląda sytuacja, jeśli wpiszemy w pliku style.css dwa style w jeden selektor, np.:
					<br>
					body section#main h1.heading { <br>
					color: red; <br>
					color: blue; <br>
					} <br>
					Pierwszeństwo będzie miał ten, który jest niżej, czyli w tym przypadku niebieski.
				</p>
				<p class="paragraph">
					<strong>Rekomendowane jest dodawanie klas do wszystkich elementów (nawet jeśli mamy tylko jeden
						element danego typu) i unikanie zagnieżdżeń przy stylowaniu (np. selektorów składających się z
						kilku elementów).</strong>
				</p>
				<p class="paragraph">
					Można przyjąć następujące wytyczne dla tworzenia nazw klas: <br>
					1. Używamy pojedynczych angielskich słów rozpoczynających się od małej litery, a jeśli jest
					konieczne użcie dwóch słów, to stosujemy kebab-case. <br>
					2. Nie zaczynamy od cyfry. <br>
					3. Nazywamy rzeczy zgodnie z ich funkcją na stronie. <br>
					4. Nie zwiększamy specyficzności bez potrzeby - staramy się, by element miał tylko jedną klasę i
					stylujemy po klasach.
				</p>
			</article>
			<article class="article">
				<h3 class="article-header">Dziedziczenie</h3>
				<p class="paragraph">
					Cześć własności, zdefiniowanych dla danego elementu, może być dziedziczona (ale nie wszystkie).
					Dziedziczenie idzie z góry do dołu, od rodzica, do potomków. Jeśli nie mamy jawnie zdefiniowanych
					stylów dla danego elementu, to dziedziczy on style od swojego rodzica, dla którego te style zostały
					zdefiniowane. Przykładowo, jeśli mamy strukturę, w ramach której jest artykuł, a w nim nagłówek h3
					oraz paragraf i ten artykuł ma nadaną klasę, w ramach której został zdefiniowany kolor czcionki, to
					kolor ten zostanie zaimplementowany również do nagłówka h3 oraz paragrafu, dla których bezpośrednio
					żadne style nie zostały zdefiniowane. Jeśli natomiast w podanym przykładzie dla paragrafu zostałaby
					nadana klasa, w ramach której zdefiniowany zostałby kolor czcionki, to nagłówek h3 odziedziczy kolor
					czcionki zdefiniowany dla artykułu, natomiast do paragrafu zostanie zastosowany kolor czcionki,
					który został dla niego zdefiniowany bezpośrednio. Taka sama sytuacja będzie miała miejsce nawet,
					jeśli do stylu zaapliowanego do artykułu dodamy importanta - do paragrafu nadal będzie miał
					zastosowanie kolor czcionki, który zdefiniowany jest dla niego bezpośrednio. Pierwszeństwo ma zawsze
					definicja jawna, bez dziedziczenia.
				</p>
				<p class="paragraph">
					Gdybyśmy mieli strukturę, w ramach której jest artykuł, a w nim nagłówek h3 oraz paragraf, w
					którym znajduje się link, i ten artykuł ma nadaną klasę, w ramach której został zdefiniowany kolor
					czcionki, to kolor ten zostanie zaimplementowany również do nagłówka h3 oraz paragrafu, dla których
					bezpośrednio żadne style nie zostały zdefiniowane. Do linku jednak kolor czcionki zdefiniowany dla
					klasy artykułu nie zostanie zaimplementowany. Mimo, że my dla linków nie mamy zdefiniowanych
					bezpośredniostylów czcionki, to takie definicje ma w sposób jawny utworzone sama przeglądarka i w
					tym przypadku do koloru czcionki linku, który znajduje si e w paragrafie, zostanie zaimplementowany
					domyślny styl z przeglądarki (można te definicje podejrzeć w devtools, badając dany element).
				</p>
				<p>
					Do definicji stylów można zastosować wartość <strong>inherit</strong>. W takim przypadku, mając
					strukturę, w ramach której jest artykuł, a w nim nagłówek h3 oraz paragraf, w którym znajduje się
					link, i ten artykuł ma nadaną klasę, w ramach której został zdefiniowany kolor czcionki, to dodając
					w stylach dla linków kolor czcionki o wartości "inherit", kolor linku zostanie odziedziczony z
					definicji dla artykułu, pomimo tego, że dla linku nie mamy zdefiniowanych kolorów jako takich i
					pomimo jawnej definicji koloru linku z przeglądarki.<br>
					article a {<br>
					color: inherit;<br>
					}<br>
					Jeśli chcemy, by linki zawsze dziedziczyły kolor z elementów powyżej i były w tym samym kolorze, co
					tekst naokoło, to można dodać w stylach definicję odnoszącą się do wszystkich linków:<br>
					a {<br>
					color: inherit;<br>
					}<br>
					W ten sposób pozbywamy się definitywnie domyślnych definicji dla koloru linków z prezglądarki i nie
					musimy tworzyć osobnych definicji dla kolorów linków w różnych miejscach. Możemy sobie je potem
					oczywiście nadpisywać, np. za pomocą klas.
				</p>
				<img class="image" src="inherited-styles.jpg"
					alt="Lista własności, których style mogą być dziedziczone." />
			</article>
		</section>
		<section class="section">
			<h2 class="section-header">CSS - tydzień 4</h2>
			<article class="article">
				<h3 class="article-header">Box model i własności CSS</h3>
				<p class="paragraph">
					Box model to fundamentalny model, z którego korzysta nasza przeglądarka do wyświetlania treści.
					Świat stron internetowych jest co do zasady płaski, dwuwymiarowy. Poruszamy się w przestrzeni x i
					y.</br>
					&lt;div&gt; tzw. pudełko, znacznik, który nie ma żadnego znaczenia semantycznego, służy do
					opakowywania różnych treści w sytuacji, gdy nie istnieje odpowiedni semantyczny znacznik. Znacznik
					ten przydaje się przy stylowaniu, ale jeśli używamy go po prostu do opakowywywania treści, to
					prawdopodobnie robimy to źle.
				</p>
				<p class="paragraph">
				<h4 class="paragraph-header">Display</h4>
				<b>display: block;</b> - powoduje, że element, który ostylujemy, nadając mu własność display o wartości
				block, zajmuje całą szerokość, jaką może zająć, a kolejne elementy będą przerzucane do nowej linii.
				Tworzony jest blok, który zajmuje całą szerokość, a kolejne rzeczy przerzucane są niżej. Jest to
				domyślny styl, jaki przeglądarka nadaje elementom na stronie (również w przypadku treści opakowanej w
				znaczniki &lt;section&gt; czy &lt;article&gt;). Styl display: block; można jednak stosować również do
				innych elementów niż te, które przeglądarka domyślnie ostylowuje w ten sposób, np. do linków, obrazków,
				etc.<br>
				Jeśli do stylowania elementu dodamy również takie własności jak wysokość i szerokość, to w sytuacji, gdy
				dostępna szerokość będzie większa niż zdefiniowana, sam element będzie miał szerkość określoną w
				definicji, ale reszta przestrzeni zostanie zarezerowana również dla tego elementu, a pozostałe elementy
				zrzucone niżej. <br>
				<img class="image" src="display-block.jpg"
					alt="Przykład treści ostylowanej za pomocą własności display: block." />
				<b>display: inline;</b> - każdy z boxów, który ostylujemy w ten sposób, dostosowuje się do tego, co się
				w nim znajduje. Nie zajmuje zatem całej dostępnej szerokości, a tylko taką, jaka potrzebna jest do
				wyświetlenia jego zawartości. Ponadto do elementu ostylowanego w ten sposób nie będą miały zastosowania
				zdefiniowane dla niego wartości height i width, element taki musi być liniowy.<br>
				<img class="image" src="display-inline.jpg"
					alt="Przykład treści ostylowanej za pomocą własności display: inline." />
				<b>display: inline-block;</b> - jest to hybryda wartości inline i block; elementy ostylowane w ten
				sposób, jeśli mają małą zawartość, to zachowują się jak elementy inline. Jeśli natomiast element jest
				szerszy i wychodzi na kolejny wiersz, to rozszerza się i blokuje całą jego szerokość.<br> Jeśli
				natomiast element taki będzie miał zdefiniowaną wysokość i szerokość, to podobnie, jak w przypadku
				wartości block, gdy jest dostępna przestrzeń większa niż zdefiniowana, element będzie miał szerokość
				określoną w definicji, ale pozostała przestrzeń nie będzie już dla niego zarezerwowana, zostanie zajęta
				przez kolejny element.<br>
				<img class="image" src="display-inline-block.jpg"
					alt="Przykład treści ostylowanej za pomocą własności display: inline-block." />
				</p>
				<p class="paragraph">
				<h4 class="paragraph-header">Width i height</h4>
				Jeśli nasz element ma zdefiniowaną wysokość i szerokość i zmniejszymy okno przeglądarki, to sam element
				pozostanie cały czas tej samej szerkości/wysokości, ale w oknie przeglądarki pojawi się scroll, który
				pozwoli na przewinięcie do fragmentów elementu niedostępnych w widoku. Jeśli natomist wartości te nie są
				zdefiniowane, to przy zmniejszaniu/zwiększaniu okna przeglądarki, wielkość elementu zmienia się,
				dostosowując do dostępnego miejsca.<br>
				<b>max-width</b> - Jeśli okno przeglądarki jest szersze niż zdefiniowana wartość dla szerkości elementu,
				to jego szerokość jest dokładnie taka, jak określono w definicji. Jeśli natomiast zmiejszymy okno
				przeglądarki i jej szerokość będzie mniejsza niż maksymalna szerokość zdefiniowana dla elementu, to
				szerokość elementu się zmniejszy i dostosowuje się on do dostępnej przestrzeni. Czyli wraz ze zmianą
				szerokości okna przeglądarki, szerokość elementu może się zmniejszać, ale nie zwiększy się bardziej niż
				wartość określona w max-width.<br>
				<b>max-height</b> - Jeśli określimy max-height i będzie ona większa niż zawartość elementu, który
				stanowi przykładowo jakiś literał, to w oknie przeglądarki element zajmie najmniejszą potrzebną mu
				wysokość - w tym przypadku jeden wiersz. Jeśli natomiast zawartość elementu jest większa niż wartość
				max-height, np. jest to wiele linijek tekstu, to element wyświetli się w maksymalnie określonej
				wysokości, natomiast jego zawartość będzie wykraczać poza przewidzianą dla elementu przestrzeń.<br>
				<img class="image" src="max-height.jpg"
					alt="Przykład treści ostylowanej za pomocą wartości max-height, gdy zawartość elementu jest wyższa i wystaje poza element." />
				</br>
				<b>min-width</b> - Jeśli ustalimy minimalną szerokość większą niż dostępna szerokość okna, to pojawi się
				scroll, który pozwoli na dostanie się do niedostępnej części elementu.<br>
				<b>min-height</b> - Jeśli ustalimy minimalną wysokość dla elementów, to te elementy, których zawartość
				nie przekracza ustalonej wysokości minimalnej będą miały taką wysokość, jak zdefiniowana minimalna.
				Jeśli natomiast zawartość elementu ma większą wysokość niż zdefiniowana minimalna, to element przyjmie
				taką wysokość, jaka jest potrzebna, by zmieścić zawartość.
				</p>
				<p class="paragraph">
				<h4 class="paragraph-header">Overflow</h4>
				Własność overflow definiuje, jak ma zachować się element w sytuacji, gdy treść za niego wystaje.<br>
				<b>overflow: hidden;</b> - ukrywa całą treść, która nie mieści się w elemencie, ucina wszystko, co
				wystaje poza jego zdefiniowaną wysokość i szerokość.<br>
				<b>overflow: auto;</b> - w sytuacji, gdy zawrtość elementu jest wyższa niż element, własność overflow o
				wartości auto dodaje wewnątrz elementu scrolla, który pozwala na dostęp do całej treści zawartej w
				elemencie.<br>
				<img class="image" src="overflow-auto.jpg"
					alt="Przykład treści ostylowanej za pomocą własności overflow: auto." /> <br>
				<b>overflow: clip;</b> - na naszym obecnym przykładzie zachowuje się jak overflow:hidden, ale gdy
				stylujemy nasze strony w bardziej zaawansowany sposób, to wykorzystujemy w sytuacji, gdy pewne elementy
				chcemy tak wypozycjonować, by wykraczały poza nasze body.<br>
				<b>overflow: scroll;</b> - dodawany jest scroll do wszystkich elementów ostylowanych w ten sposób,
				niezależnie od wysokości i szerokości. Nie we wszystkich elementach scroll będzie działać, a jedynie w
				tych, w przypadku których zawartość elementu wykracza poza określoną dla niego wysokość lub szerokość. W
				przypadku overflow: auto, scroll dodawany jest tylko tam, gdzie jest naprawdę potrzebny.<br>
				<img class="image" src="overflow-scroll.jpg"
					alt="Przykład treści ostylowanej za pomocą własności overflow: scroll." /> <br>
				<b>overflow: visible;</b> - powoduje, że treść, która wykracza poza dostępną wysokość lub szerokość
				elementu nie jest ukrywana, ale wystaje za element. Jeśli za elementem, z którego wystaje treść,
				umieścimy kolejny, w którym określona dla niego zawrtość się mieści, to element ten dodawany jest od
				razu za poprzedzającym go elementem. Przestrzeń nie jest rezerowana na niemieszczącą się treść. W takiej
				sytuacji treści obu elementów mogą się na siebie nakładać.<br>
				<img class="image" src="overflow-visible.jpg"
					alt="Przykład treści ostylowanej za pomocą własności overflow: visible." />
				</p>
			</article>
			<article class="article">
				<h3 class="article-header">Jednostki</h3>
				<p class="paragraph">
				<h4 class="paragraph-header">Piksele</h4>
				Wartość 0 możemy zapisywać bez jednostek. Nie ma znaczenia, czy są to piksele, procenty czy jeszcze coś
				innego, zapisujemy po prostu 0.<br>
				Piksele zapisujemy jako px, piksel jest to po prostu punkt na ekranie. Jednostke zapisujemy razem z
				liczbą, bez spacji, np. 200px, w przeciwnym razie to nie zadziała. Piksel jako jednostka nie ma
				przełożenia na gęstość pikselową ekranów. Piksele określające np. rozdzielczość HD składają się na
				większe piksele, które stosowane są jako jednostki. To, że rozdzielczość ekranów zmienia się, składa się
				na nią coraz większa liczba pikseli, poprawiając jakość obrazu, nie wpływa na zmianę wielkości piskeli
				jako jednostek, które wciąż pozostają takie same. Przeglądarka sobie to poprawnie przelicza.
				</p>
				<p class="paragraph">
				<h4 class="paragraph-header">Procenty</h4>
				Procenty zapisujemy jako %, również bez spacji, np. 50%. Wartość ta musi mieć jakiś punkt odniesienia,
				rodzica, w naszym przypadku będzie to po prostu body. Jeśli podamy dla elementu szerokość 50%, to będzie
				on zajmował połowę dostępnego okna przeglądarki. W przypadku wysokości natomiast nie jest to już tak
				proste, bo rodzic nie ma domyślnej wartości, do której moglibyśmy się odnieść, a wysokość okna zależy od
				zawartości elementów, co może być zmienne. Jeśli chcemy wysokość jakiegość elementu określić procentowo,
				to musimy zdefiniować wysokość dla wszystkich elementów nadrzędnych, w których dany element jest
				zagnieżdżony. W przypadku div'a zagnieżdżonego bezpośrednio w body, aby określić jego procentową
				wysokość, musimy określić wysokość body oraz naszego root'a, czyli html np. jako 100% albo w pikselach.
				Generalnie jednak nie definiujemy wysokości w ten sposób jak na podanym przykładzie, jest to bardzo
				ekstremalny przypadek.<br>
				<img class="image" src="height-in-percent.jpg"
					alt="Przykład treści ostylowanej za pomocą wysokości zdefiniowanej w procentach." /><br>
				Jeśli natomiast będziemy mieć element zawarty w innym elemencie, którego wysokość i szerokość zostały
				zdefiniowane, do nadając temu zagnieżdżonemu elementowi wysokość i szerokość o wartości 50%, zajmie on
				połowę wysokości i szerokości rodzica, a nie całego body.
				</p>
				<p class="paragraph">
				<h4 class="paragraph-header">Viewport width i viewport height</h4>
				Viewport width (vw) jest to jednostka odnosząca się do szerokości okna, w którym wyświetla się nasz
				dokument. Jednostka ta zawsze działa w kontekście szerokości całego ekranu, czyli nawet jeśli mamy
				element zagnieżdżony w innym elemencie o określonej szerokości, to nadając temu zagnieżdżonemu
				elementowi szerokość 50vw, zajmie on połowę dostępnego ekranu, a nie połowę szerokości rodzica.<br>
				W przypadku jednostki viewport height (vh) jej zastosowanie nie powoduje takich problemów jak
				definiowanie wysokości w procentach. Jednostka vieport height bazuje na wysokości dostępnego okna, w
				którym wyświetla się treść, a nie wysokości całego dokumentu. Czyli jeśli wysokość elementu zdefiniujemy
				na 33vh, to zajmie on 33% dostępnego okna przeglądarki. Jeśli natomiast wysokość elementu zdefiniujemy
				na 100vh, to zajmie on 100% dostępnego okna przeglądarki i by dostać się do treści spoza elementu,
				będziemy musieli się przescrollować. Można w ten sposób np. wykonać pokaz slajdów na stronie.
				</p>
			</article>
			<article class="article">
				<h3 class="article-header">Box model</h3>
				<p class="paragraph">

					Wszystkie elementy na stronie internetowej otoczone są niewidzialnym prostokątem, który ma jakąś
					wysokość i szerokość i który możemy podejrzeć, najeżdżąjąc na te elementy za pomocą devtools. Box
					model jest to zatem opis wymiarów naszego elementu, który składa się z kilku wartości:<br>
					- element - znajduje się w środku i ma określoną wysokość i szerokość;<br>
					- padding - jest to wewnętrzny margines, który definiuje, jaka ma być odległość między treścią,
					zawartością naszego elementu a ramką tego elementu;<br>
					- border - ramka elementu, zamyka element;<br>
					- margin - nie jest już częścią elementu, ale definiuje jego zachowanie, określa o ile nasz element
					ma być oddalony od innych elementów i o ile te inne elementy mają być oddalone od naszego
					elementu.<br>
					Box model dla danego elementu można podejrzeć w devtools. Wartości są tam opisane w pikselach.<br>
					<img class="image" src="box-model.jpg"
						src="Box model składający się z elementu, paddingu, borderu i marginu." />
				</p>
				<p class="paragraph">
				<h4 class="paragraph-header">Padding</h4>
				Padding, czyli wewnętrzny margines, jest własnością, która posiada kilka wartości. Można go opisać w
				sposób pełny, podając odległość od treści elementu od ramki po stronie lewej, prawej oraz od góry i
				dołu, opisując każdą z wartości osobno i definiując je w sposob jawny. Można również dokonać zapisu
				skrótowego (shorthand), bez opisywania każdej strony osobno, podając same wartości dla paddingu według
				określonej kolejności, zgodnie z ruchem wskazówek zegara: góra prawo, dół, lewo. Jeśli natomiast padding
				będzie miał przypisaną tylko jedną wartość, to będzie ona miała zastosowanie do wszystkich czterech
				stron. Innymi słowy, jeśłi wszystkie wartości paddingu są takie same, to wystarczy opisać padding za
				pomocą tej jednej wartości (np. padding: 10px), bez wyszczególniania padding-bottom, padding-top,
				padding-left, padding-right.<br>
				<img class="image" src="padding-description.jpg"
					alt="Przykład zapisu pełnego i skróconego dla paddingu." /> <br>
				Padding można opisać również za pomocą tzw. wartości lustrzanych, jeśli chcemy, by wartości góra/dół
				oraz prawo/lewo, były takie same. Możemy podać w takiej sytuacji dla paddingu tylko dwie wartości i
				wówczas zostaną one dobrane parami - pierwsza zostanie przypisana do odległości góra/dół, z kolei druga
				dla stron prawo/lewo.<br>
				<img class="image" src="padding-mirror-values.jpg"
					alt="Przykład zapisu wartości lustrzanych dla paddingu." /><br>
				</p>
				<p class="paragraph">
				<h4 class="paragraph-header">Border</h4>
				Podobnie jak padding, border również może być opisany w sposób pełny i zawierający definicje wszystkich
				własności lub w sposób skrótowy (shorthand), gdzie wszytskie wartości są wrzucone do jednej własności o
				nazwie border. Border może być opisany za pomocą wartości:<br>
				- border-width - opisuje szerokość ramki;<br>
				- border-style - opisuje styl ramki, wartość ta musi być podana, by ramka się w ogóle pojawiła;<br>
				- border-color - opisuje kolor ramki.<br>
				Jeśli dany element zostanie ostylowany podwójnie, np. za pomocą opisu pełnego i skrótowego, gdzie będą
				podane różne wartości, to zgodnie z ogólnymi regułami specyficzności, zastosowanie będzie miał styl
				znajdujący się niżej w pliku, czyli ten, który de facto jest bliżej danego elementu.<br>
				Ramka nie musi znajdować się po każdej ztronie elementu, możemy sobie zdefiniować, po której stronie
				chcemy ją umieścić, opisując ją za pomocą wartości border-bottom, border-left, border-top, border-right,
				definiując tylko tę stronę, po której chcemy mieć ramkę. Jeśli natomiast damy definicję ogólną dla
				border, to style poszczególnych stron ramki możemy sobie nadpisywać dodając definicje np. dla border-top
				i border-bottom. W podanym przykładzie ramka po stronie lewej i prawej będzie ostylowana według
				definicji ogólnej, natomiast góra i dół ramki zostaną ostylowane według definicji szczegółówych
				określonych w sposób jawny dla border-bottom i border-top.<br>
				<img class="image" src="border-description.jpg"
					alt="Własność border opisana w sposób pełny i skrótowy." /><br>
				Do ramki można dodać również efekt zaokrąglenia za pomocą wartości <strong>border-radius</strong>. Żeby
				skorzystać z tego efektu nie musimy wcale mieć definicji dla ramki - w takiej sytuacji zaokrąglony
				zostanie sam element. Border-radius opisujemy za pomocą pikseli lub procentów. Jeśli określimy, ze
				border-radius: 100%, to dany element zostanie zaokrąglony na całej długości i szerokości. Border-radius
				można również wykorzystać do zrobienia kółka za pomocą CSS. Aby uzyskać taki efekt, element musi mieć
				taką samą wysokość i szerokość i definiujemy dla niego border-radius: 100%.<br>
				<img class="image" src="border-radius.jpg"
					alt="Przykłady elementów ostylowanych za pomocą własności border-radius." />
				</p>
				<p class="paragraph">
				<h4 class="paragraph-header">Margin</h4>
Marginesy zapisujemy tak samo jak padding. Marginesy zewnętrzne nakładają się na siebie, co zonacza, ze jeśli mamy obok siebie dwa elementy i dla jednego zdefiniujemy margin: 100px, a dla drugiego margin: 120px, to odległóść między tymi elementami wyniesie 120px, a nie 220px. Dla marginesów występują również wartości lustrzane, które wykorzystywane są często by wyśrodkować dany element. By uzyskać taki efekt do własności margin dodajemy dwie wartości - odstęp oraz auto, np. margin: 50px auto. Jeśli element zajmuje całą dostępną szerokość okna, to będzie po prostu oddalony o krawędzi okna o wartość zdefiniowaną dla margin, jeśli jednak szerokość elementu jest mniejsza niż dostępne okno przeglądarki, to wartość auto sprawi, że element zostanie wyśrodkowany. Jeśli dany element jest zagnieżdżony w innym divie, to w takim przypadku będzie centrowany nie do dostępnego omna, ale w ramach swojego rodzica, nadrzędnego diva.<br>
<img class="image" src="margin-auto.jpg" alt="Element wyśrodkowany za pomocą wartości auto zdefiniowanej dla marginesu."/>
				</p>
			</article>
			<article class="article">
				<h3 class="article-header">Box sizing</h3>
				<p class="paragraph">
				</p>
			</article>
		</section>

	</main>
	<footer class="footer">Strona domowa Magdaleny Derek, wszystkie treści są wynikiem nauki w ramach szkolenia WTF: Co
		ten frontend.
		<a class="footer-link" href="#top">Wróć na górę strony ⬆️</a>
	</footer>
	<script src="main.js"></script>
</body>

</html>