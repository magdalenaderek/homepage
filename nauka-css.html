<!DOCTYPE html>
<html lang="pl">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Notatki z frontendu</title>
	<link href="/normalize.css" rel="stylesheet" type="text/css">
	<link href="/style.css" rel="stylesheet" type="text/css">
</head>

<body class="body">
	<header class="header">
		<nav class="navigation">
			<a class="navigation__link" href="/index.html">Strona główna</a>
			<a class="navigation__link" href="/nauka-html.html">Nauka HTML</a>
			<a class="navigation__link" href="/nauka-css.html">Nauka CSS</a>
			<a class="navigation__link" href="/nauka-js.html">Nauka JavaScriptu</a>
			<a class="navigation__link" href="/nauka-varia.html">Nauka - varia</a>
		</nav>

	</header>
	<main class="main">
		<header>
			<h1 id="top" class="main__header">Nauka CSS-a</h1>

		</header>
		<section class="section">
			<h2 class="section__header">CSS - tydzień 2</h2>
			<article class="article">
				<h3 class="article__header">CSS - podstawowe informacje i selektory, kolory</h3>
				<p class="article__paragraph"><b>CSS – Cascading style sheets</b> – odpowiada za prezentację, wygląd
					treści.
					Każdy język ma swoją składnię, w przypadku CSS są to reguły, mające następującą budowę: <br>
					selektor { <br>
					właściwość: wartość; <br>
					}
				</p>
				<p class="article__paragraph">Style co do zasady definiuje się w osobnym pliku o rozszerzeniu .css, ale
					można je
					też zdefiniować w
					pliku html w sekcji "head" poprzez dodanie znacznika "style", gdzie definiujemy właściwości
					poszczególnych elementów, odnosząc się do nich za pomocą selektorów, którymi mogą być nazwy tych
					elementów (np. h1, p), np.: <br>
					p { <br>
					color: green; <br>
					}
				</p>
				<p class="article__paragraph">Sposobów zapisu kolorów jest kilka, np. angielska nazwa, zapis
					heksadecymalny,
					czyli w systemie
					szestnastkowym - #xxyyzz, gdzie xx to kanał czerwony, yy to kanał zielony, a zz to kanał niebieski.
					Style określa się jednak najczęściej w zewnętrznym arkuszu stylów, a w samym pliku html zawiera się
					do niego odnośnik poprzez odpowiednia frazę – znacznik "link" o odpowiedniej składni.
					Kolejną własnością, obok koloru, jest tło. Można je określić dla całej strony wskazując jako
					selektor "body", czyli np.: <br>
					body { <br>
					background: lightyellow; <br>
					}
				</p>
				<p class="article__paragraph">
					Możemy zaprojektować paletę kolorystyczną naszej strony posiłkując się
					<a class="article__link" href="https://coolors.co">generatorem coolors</a>
				</p>
			</article>
		</section>
		<section class="section">
			<h2 class="section__header">CSS - tydzień 3</h2>
			<article class="article">
				<h3 class="article__header">Stylowanie w oparciu o atrybuty element, id i klasa</h3>
				<p class="article__paragraph">
					Oprócz tego, że style można zamieścić w ramach znacznika style w sekcji "head" lub w pliku
					zewnętrznym, można je też zastosować używając atrybutu "style" i przypisując go do konkretnego
					znacznika, np. section, h1, p, etc. wg schematu: <br>
					znacznik style="color:yellow; background:#ffffff;" treść /znacznik <br>
					Styl przy znaczniku z wykorzystaniem atrybutu "style" nazywamy stylem inline, liniowym. Znajduje on
					zastosowanie jedynie do tego konkretnego znacznika, przy którym atrybut ten został wpisany. <br>
					Aplikowanie stylów w ten sposób nie ma jednak większego sensu, bo robi się bałagan - kod staje się
					nieczytelny i trudny do modyfikacji. I tutaj właśnie w grę wchodzą tzw. prawdziwe selektory -
					wcześniej stylowaliśmy odnosząc się do elementów, natomiast najlepiej to robić w oparciu o
					identyfikatory i klasy: #id i .class. Zwłaszcza klasy, które dodaje się do znaczników wg schematu:
					<br>
					znacznik class="name" treść /znacznik <br>
					Atrybut .class dodajemy w html przy danych tagach/znacznikach (pozwala na pogrupowanie elementów),
					natomiast przekłada się on na stylowanie i cssy. Nazwę, którą nadajemy danej klasie, tworzymy wg
					schematu kebab-case. Aby ostylować elementy, które mają przypisaną daną klasę, odnosimy się do nich
					w pliku ze stylami w następujący sposób: <br>
					.name { <br>
					właściwość: wartość; <br>
					} <br>
					.(kropka) - to selektor klasy
				</p>
				<p class="article__paragraph">
					Do stylowania elementów można wykorzystać również id, które wcześniej nadaliśmy tagom po to, by
					wykorzystać je jako kotwicę służącą do przenoszenia się w ramach dokumentu do konkretnej sekcji.
					Identyfikator nadaje się elementom i wykorzystuje do stylowania wg następującego schematu: <br>
					znacznik id="name" treść /znacznik <br>
					#name { <br>
					właściwość: wartość; <br>
					} <br>
					# (hash) - to selektor id <br>
					Na danej stronie dokumentu może znajdować się tylko jedno id o danej konkretnej wartości, przypisane
					do jednego konkretnego elementu.
				</p>
				<p class="article__paragraph">
					Selektory można łączyć, czyli do danego znacznika może byc przypisane konkretne id i określona
					klasa. <br>
					Jeśli chcemy ostylować wg określonego wzoru wszystkie linki, które znajdują się w obszarze nawigacji
					"nav", tak by stylowanie odróżniało je od pozostałych linków występujących w treści dokumentu.
					Elementy o znaczniku "a" są zatem zagnieżdżone w znaczniku "nav", chcemy więc ostylować elementy
					znajdujące się w innym elemencie. Odnosimy się do nich w pliku z cssami wpisując po sobie elementy
					"nav" i po spacji "a" wg wzoru: <br>
					nav a { <br>
					własność: wartość1; <br>
					} <br>
					a { <br>
					własność: wartość2; <br>
					} <br>
					Przy takim zapisie style nie zaaplikują się do samego znacznika "nav", ale do zawartych w nim
					elementów "a", gdzie dana własnośc będzie miała wartość1. Natomiast pozostałe elementy "a", które
					nie są zagnieżdżone w "nav" przyjmą wartość2 dla tej własności. Odnosząc się do elementów "a"
					zawartych w "nav" nie musimy więc podawać dokładnej ścieżki body>header>nav, wystarczy podanie
					bezpośredniego rodzica, czyli "nav". Nie musi to być również bezpośredni rodzic - w tym przypadku
					ten sam efekt osiągniemy wpisując ścieżkę header>a.
				</p>
			</article>
			<article class="article">
				<h3 class="article__header">!important i specyficzność w CSS</h3>
				<p class="article__paragraph">
					!important to zmora, jeśli chodzi o stylowanie. Nie powinno się tego używać, ponieważ !important
					dopisany przy wartości dla danej własności opisującej określony element sprawia, że styl, przy
					którym został on dodany nadpisuje wszystkie inne style, które zostały zdefiniowane dla danego
					elementu. Opierając się na wcześniejszym przykładzie rozróżnienia stylów linków zagnieżdżonych w
					znaczniku "nav" oraz linków znajdujących się poza tym znacznikiem w treści dokumentu, dodanie
					"!important" przy własności zdefiniowanej dla linków niezagnieżdżonych sprawia, że wszystkie linki,
					zagnieżdżone i niezagnieżdżone, zostaną ostylowanie zgodnie z tym stylem. Przykład takiego zapisu:
					<br>
					nav a { <br>
					własność: wartość1; <br>
					} <br>
					a { <br>
					własność: wartość2 !important; <br>
					} <br>
					Wstawienie importanta w jakimś miejscu może więc sprawić, że stylowanie całej strony się posypie.
					Zatem jeśli nie musimy i zastosowanie importanta nie jest naprawdę celowe w danym przypadku, to go
					nie używajmy.
				</p>
				<p class="article__paragraph">
					Co w sytuacji, gdy do danego elementu mamy zdefiniowane stylowanie zarówno w pliku css, jak i przy
					danym znaczniku jako inline, tak jak na poniższym przykładzie? <br>
					W pliku CSS mamy zapis: <br>
					#name { <br>
					color: red; <br>
					} <br>
					Natomiast w kodzie html przy danym elemencie mamy wstawiony inline: <br>
					span id="name" style="color: yellow" treść /span <br>
					Dla treści elementu span o id=name mamy więc zdefiniowany w pliku css kolor czerwony, natomiast w
					stylu liniowym kolor żółty. Przeglądarka zastosuje tutaj styl zdefiniowany w inline, czyli treść
					będzie miała kolor żółty. <br>
					Jest to przykład występowania specyficzności w CSS, czyli zasad ważności sposobów zastosowania
					stylów w sytuacji, gdy są one w konflikcie. Specificity to zatem zasada, która określa który
					selektor ma pierwszeństwo w przypadku, kiedy wiele z nich ustawia te same reguły CSS dla tego samego
					znacznika HTML. Kolejność ta została zwizualizowana na poniższym obrazku.
				</p>
				<img class="image" src="/specificity-rules.JPG"
					alt="Obrazek przedstawiający kolejność zastosowania selektorów: important, inline, id, klasa, element." />
				<p class="article__paragraph">
					Zastosowanie ma zatem następująca kolejność wg pierwszeństwa obowiązywania reguł wprowadzonych przez
					selektory: important, inline, id, klasa, element. Przy czym dwa pierwsze, important i inline, są
					stosowane rzadko, dlatego zostały ujęte w nawiasie. <br>
					Przykładowo, jeśli mamy zdefiniowane dwie reguły css dla znacznika h1 w taki sposób jak poniżej,
					czyli w jednej z nich jako selektor podajemy sam pojedynczy znacznik h1, natomiast w drugiej
					uwzględniamy zagnieżdżenie tego znacznika h1 w elemencie body (jako selektor podajemy dwa elementy -
					dziecko i rodzica), to w opierając się na zasadach specificity, zastosowanie będzie miała reguła CSS
					zdefiniowana w oparciu o selektor z dwoma elementami (bo dwa elementy to więcej niż jeden element).
					<br>
					h1 { <br>
					color: red; <br>
					} <br>
					body h1 { <br>
					color: yellow; <br>
					} <br>
					Nagłówek będzie zatem żółty, ponieważ reguła CSS definiująca ten styl <b>ma wyższą
						specyficzność</b>. Poniżej znajduje się obrazek przedstawiający wizualizację tego
					przykładu.
				</p>
				<img class="image" src="/specificity-example1.JPG"
					alt="Obrazek przedstawiający pierwszeństwo zastosowania reguł CSS, gdy jedna jest zdefiniowana w oparciu o selektor jednoelementowy, a druga dwuelementowy." />
				<p class="article__paragraph">
					To, która z reguł CSS będzie miała zastosowane jest również widoczne w devtools w przeglądarce -
					styl, który został nadpisany jest przekreślony. Przekreślone są również zwykle domyślne style
					przeglądarki, gdy są nadpisywane przez nas. W tym przypadku nie są przekreślone, bo taka własność
					nie została zdefiniowana w przeglądarce (zadziałoby się tak np. w przypadku stylów zdefiniowanych
					dla
					linków). Poniżej zrzut ekranu z devtools dla omawianego przypadku.
				</p>
				<img class="image" src="/specificity-example-devtools.jpg"
					alt="Zrzut ekranu z devtools przedstawiający pierwszeństwo zastosowania reguł CSS, gdy jedna jest zdefiniowana w oparciu o selektor jednoelementowy, a druga dwuelementowy." />
				<p class="article__paragraph">
					Devtools pozwala też na dodanie w zakładce elements do znacznika body atrybutu "contenteditable",
					poprzez
					kliknięcie prawym przyciskiem i wybór opcji add atribute. Po dodaniu atrybutu można na żywo edytować
					stronę z
					poziomu jej widoku, a nie narzędzi w devtools.
				</p>

				<p class="article__paragraph">
					Kolejnym przykładem zastosowania reguł specyficzności css jest sytuacja, gdy do danego nagłówka
					zostały użyte reguły css, z których jedna styluje go w oparciu o selektor składający się z trzech
					elementów, natomiast druga używa selektora w postaci id. <br>
					html body h1 { <br>
					color: yellow; <br>
					} <br>
					#main-header { <br>
					color: red; <br>
					} <br>
					Wyższą specyficzność będzie miała tu reguła definiująca kolor czerwony. Mimo tego, że kolor żółty
					opiera sie na selektorze składającym się z trzech elementów, a kolor czerwony określany jest dla
					selektora składającego sie z jednego id, to id ma większą wagę i pierwszeństwo w zasadach
					specyficzności. Wizualizację tego przykładu zawiera poniższy obrazek.
				</p>
				<img class="image" src="/specificity-example2.JPG"
					alt="Obrazek przedstawiający pierwszeństwo zastosowania reguł CSS, gdy jedna jest zdefiniowana w oparciu o selektor trójelementowy, a druga selektor id." />
				<p class="article__paragraph">
					Na kolejnym przykładzie mamy sytuację, gdy jeden ze stylów zdefiniowany jest w oparciu o id i trzy
					elementy, natomiast drugi w oparciu o id, klasę i jeden element. Wyższą specyficzność będzie miała
					reguła CSS bazująca na id, klasie i jednym elemencie, ponieważ zawiera więcej selektorów o wyższej
					wadze - id i klasa (2). Można to też przeczytać jako całe liczby i w ten sposób 111 > 103, a zatem
					nagłówek będzie miał kolor czerwony. Poniżej zapis kodu i obrazek, który ilustruje ten przykład.<br>
					(Selektor id piszemy łącznie z selektorem elementu, do którego się odnosi, bez spacji. To samo w
					przypadku selektora klasy, który odnosi się do danego elementu).
					<br>
					html body h1#main-header { <br>
					color: yellow; <br>
					} <br>
					body .section #main-header { <br>
					color: red; <br>
					}
				</p>
				<img class="image" src="/specificity-example3.JPG"
					alt="Obrazek przedstawiający pierwszeństwo zastosowania reguł CSS, gdy jedna jest zdefiniowana w oparciu o id i trzy elementy, a druga w oparciu o selektor id, klasę i jeden element." />
				<p class="article__paragraph">
					<strong>Jeśli specyficzność jest równa, to pierwszeństwo ma selektor znajdujący się "bliżej"
						elementu.</strong> <br>
					Przykładowo w jednym pliku style.css mamy zdefiniowane dwie reguły składające się z tych samych
					selektorów,
					lecz każda z tych reguł styluje dany element w inny sposób. I jedna z reguł znajduje się pod drugą w
					treści pliku, przy czym reguła definiująca kolor czerwony znajduje się wyżej niż reguła stylująca
					kolor niebieski. Zastosowanie będzie miała tu reguła stylująca kolor niebieski, czyli ta, która jest
					niżej, ponieważ znajduje się ona bliżej stylowanego elementu.<br>
					body section#main h1.heading { <br>
					color: red; <br>
					} <br>
					body section#main h1.heading { <br>
					color: blue; <br>
					}
				</p>
				<p class="article__paragraph">
					Aby unaocznić sobie, na czym polega ta bliskość, wyobrażamy sobie, że style zdefiniowane w pliku
					style.css są umieszczone w pliku HTML w miejscu, gdzie znajduje się odniesienie do pliku css. Na
					przykładzie zobrazowanym poniżej element header ma przypisaną klasę "styl1", w oparciu o którą
					został ostylowany w pliku css, gdzie dla tej samej reguły określono dwa różne style. Zastosowany
					zostanie styl definiujący kolor niebieski, ponieważ jest umieszczony niżej, a tym samym fizycznie
					znajduje się bliżej elementu header.
				</p>
				<img class="image" src="/specificity-example4.JPG"
					alt="Zrzut ekranu przedstawiający, na czym polega bliskość stylowanego elementu reguły znajdującej sie niżej w pliku." />
				<p class="article__paragraph">
					Analogicznie wygląda sytuacja, jeśli wpiszemy w pliku style.css dwa style w jeden selektor, np.:
					<br>
					body section#main h1.heading { <br>
					color: red; <br>
					color: blue; <br>
					} <br>
					Pierwszeństwo będzie miał ten, który jest niżej, czyli w tym przypadku niebieski.
				</p>
				<p class="article__paragraph">
					<strong>Rekomendowane jest dodawanie klas do wszystkich elementów (nawet jeśli mamy tylko jeden
						element danego typu) i unikanie zagnieżdżeń przy stylowaniu (np. selektorów składających się z
						kilku elementów).</strong>
				</p>
				<p class="article__paragraph">
					Można przyjąć następujące wytyczne dla tworzenia nazw klas: <br>
					1. Używamy pojedynczych angielskich słów rozpoczynających się od małej litery, a jeśli jest
					konieczne użcie dwóch słów, to stosujemy kebab-case. <br>
					2. Nie zaczynamy od cyfry. <br>
					3. Nazywamy rzeczy zgodnie z ich funkcją na stronie. <br>
					4. Nie zwiększamy specyficzności bez potrzeby - staramy się, by element miał tylko jedną klasę i
					stylujemy po klasach.
				</p>
			</article>
			<article class="article">
				<h3 class="article__header">Dziedziczenie</h3>
				<p class="article__paragraph">
					Cześć własności, zdefiniowanych dla danego elementu, może być dziedziczona (ale nie wszystkie).
					Dziedziczenie idzie z góry do dołu, od rodzica, do potomków. Jeśli nie mamy jawnie zdefiniowanych
					stylów dla danego elementu, to dziedziczy on style od swojego rodzica, dla którego te style zostały
					zdefiniowane. Przykładowo, jeśli mamy strukturę, w ramach której jest artykuł, a w nim nagłówek h3
					oraz paragraf i ten artykuł ma nadaną klasę, w ramach której został zdefiniowany kolor czcionki, to
					kolor ten zostanie zaimplementowany również do nagłówka h3 oraz paragrafu, dla których bezpośrednio
					żadne style nie zostały zdefiniowane. Jeśli natomiast w podanym przykładzie dla paragrafu zostałaby
					nadana klasa, w ramach której zdefiniowany zostałby kolor czcionki, to nagłówek h3 odziedziczy kolor
					czcionki zdefiniowany dla artykułu, natomiast do paragrafu zostanie zastosowany kolor czcionki,
					który został dla niego zdefiniowany bezpośrednio. Taka sama sytuacja będzie miała miejsce nawet,
					jeśli do stylu zaapliowanego do artykułu dodamy importanta - do paragrafu nadal będzie miał
					zastosowanie kolor czcionki, który zdefiniowany jest dla niego bezpośrednio. Pierwszeństwo ma zawsze
					definicja jawna, bez dziedziczenia.
				</p>
				<p class="article__paragraph">
					Gdybyśmy mieli strukturę, w ramach której jest artykuł, a w nim nagłówek h3 oraz paragraf, w
					którym znajduje się link, i ten artykuł ma nadaną klasę, w ramach której został zdefiniowany kolor
					czcionki, to kolor ten zostanie zaimplementowany również do nagłówka h3 oraz paragrafu, dla których
					bezpośrednio żadne style nie zostały zdefiniowane. Do linku jednak kolor czcionki zdefiniowany dla
					klasy artykułu nie zostanie zaimplementowany. Mimo, że my dla linków nie mamy zdefiniowanych
					bezpośredniostylów czcionki, to takie definicje ma w sposób jawny utworzone sama przeglądarka i w
					tym przypadku do koloru czcionki linku, który znajduje si e w paragrafie, zostanie zaimplementowany
					domyślny styl z przeglądarki (można te definicje podejrzeć w devtools, badając dany element).
				</p>
				<p class="article__paragraph">
					Do definicji stylów można zastosować wartość <strong>inherit</strong>. W takim przypadku, mając
					strukturę, w ramach której jest artykuł, a w nim nagłówek h3 oraz paragraf, w którym znajduje się
					link, i ten artykuł ma nadaną klasę, w ramach której został zdefiniowany kolor czcionki, to dodając
					w stylach dla linków kolor czcionki o wartości "inherit", kolor linku zostanie odziedziczony z
					definicji dla artykułu, pomimo tego, że dla linku nie mamy zdefiniowanych kolorów jako takich i
					pomimo jawnej definicji koloru linku z przeglądarki.<br>
					article a {<br>
					color: inherit;<br>
					}<br>
					Jeśli chcemy, by linki zawsze dziedziczyły kolor z elementów powyżej i były w tym samym kolorze, co
					tekst naokoło, to można dodać w stylach definicję odnoszącą się do wszystkich linków:<br>
					a {<br>
					color: inherit;<br>
					}<br>
					W ten sposób pozbywamy się definitywnie domyślnych definicji dla koloru linków z prezglądarki i nie
					musimy tworzyć osobnych definicji dla kolorów linków w różnych miejscach. Możemy sobie je potem
					oczywiście nadpisywać, np. za pomocą klas.
				</p>
				<img class="image" src="/inherited-styles.jpg"
					alt="Lista własności, których style mogą być dziedziczone." />
			</article>
		</section>
		<section class="section">
			<h2 class="section__header">CSS - tydzień 4</h2>
			<article class="article">
				<h3 class="article__header">Box model i własności CSS</h3>
				<p class="article__paragraph">
					Box model to fundamentalny model, z którego korzysta nasza przeglądarka do wyświetlania treści.
					Świat stron internetowych jest co do zasady płaski, dwuwymiarowy. Poruszamy się w przestrzeni x i
					y.<br>
					&lt;div&gt; tzw. pudełko, znacznik, który nie ma żadnego znaczenia semantycznego, służy do
					opakowywania różnych treści w sytuacji, gdy nie istnieje odpowiedni semantyczny znacznik. Znacznik
					ten przydaje się przy stylowaniu, ale jeśli używamy go po prostu do opakowywywania treści, to
					prawdopodobnie robimy to źle.
				</p>
				<p class="article__paragraph">Display: block</p>
				<p class="article__paragraph">
					Element, który ostylujemy, nadając mu własność display o wartości
					block, zajmuje całą szerokość, jaką może zająć, a kolejne elementy będą przerzucane do nowej linii.
					Tworzony jest blok, który zajmuje całą szerokość, a kolejne rzeczy przerzucane są niżej. Jest to
					domyślny styl, jaki przeglądarka nadaje elementom na stronie (również w przypadku treści opakowanej
					w
					znaczniki &lt;section&gt; czy &lt;article&gt;). Styl display: block; można jednak stosować również
					do
					innych elementów niż te, które przeglądarka domyślnie ostylowuje w ten sposób, np. do linków,
					obrazków,
					etc.<br>
					Jeśli do stylowania elementu dodamy również takie własności jak wysokość i szerokość, to w sytuacji,
					gdy
					dostępna szerokość będzie większa niż zdefiniowana, sam element będzie miał szerkość określoną w
					definicji, ale reszta przestrzeni zostanie zarezerowana również dla tego elementu, a pozostałe
					elementy
					zrzucone niżej.
				</p>
				<img class="image" src="/display-block.jpg"
					alt="Przykład treści ostylowanej za pomocą własności display: block." />
				<p class="article__paragraph">Display: inline</p>
				<p class="article__paragraph">
					Każdy z boxów, który ostylujemy w ten sposób, dostosowuje się do tego, co się
					w nim znajduje. Nie zajmuje zatem całej dostępnej szerokości, a tylko taką, jaka potrzebna jest do
					wyświetlenia jego zawartości. Ponadto do elementu ostylowanego w ten sposób nie będą miały
					zastosowania
					zdefiniowane dla niego wartości height i width, element taki musi być liniowy.
				</p>
				<img class="image" src="/display-inline.jpg"
					alt="Przykład treści ostylowanej za pomocą własności display: inline." />
				<p class="article__paragraph">Display: inline-block</p>
				<p class="article__paragraph">
					Jest to hybryda wartości inline i block. Elementy ostylowane w ten
					sposób, jeśli mają małą zawartość, to zachowują się jak elementy inline. Jeśli natomiast element
					jest
					szerszy i wychodzi na kolejny wiersz, to rozszerza się i blokuje całą jego szerokość.<br> Jeśli
					natomiast element taki będzie miał zdefiniowaną wysokość i szerokość, to podobnie, jak w przypadku
					wartości block, gdy jest dostępna przestrzeń większa niż zdefiniowana, element będzie miał szerokość
					określoną w definicji, ale pozostała przestrzeń nie będzie już dla niego zarezerwowana, zostanie
					zajęta
					przez kolejny element.
				</p>
				<img class="image" src="/display-inline-block.jpg"
					alt="Przykład treści ostylowanej za pomocą własności display: inline-block." />
			</article>
			<article class="article">
				<h3 class="article__header">Width i height</h3>
				<p class="article__paragraph">
					Jeśli nasz element ma zdefiniowaną wysokość i szerokość i zmniejszymy okno przeglądarki, to sam
					element
					pozostanie cały czas tej samej szerkości/wysokości, ale w oknie przeglądarki pojawi się scroll,
					który
					pozwoli na przewinięcie do fragmentów elementu niedostępnych w widoku. Jeśli natomist wartości te
					nie są
					zdefiniowane, to przy zmniejszaniu/zwiększaniu okna przeglądarki, wielkość elementu zmienia się,
					dostosowując do dostępnego miejsca.
				</p>
				<p class="article__paragraph">max-width</p>
				<p class="article__paragraph">
					Jeśli okno przeglądarki jest szersze niż zdefiniowana wartość dla szerkości elementu,
					to jego szerokość jest dokładnie taka, jak określono w definicji. Jeśli natomiast zmiejszymy okno
					przeglądarki i jej szerokość będzie mniejsza niż maksymalna szerokość zdefiniowana dla elementu, to
					szerokość elementu się zmniejszy i dostosowuje się on do dostępnej przestrzeni. Czyli wraz ze zmianą
					szerokości okna przeglądarki, szerokość elementu może się zmniejszać, ale nie zwiększy się bardziej
					niż
					wartość określona w max-width.
				</p>
				<p class="article__paragraph">max-height</p>
				<p class="article__paragraph">
					Jeśli określimy max-height i będzie ona większa niż zawartość elementu, który
					stanowi przykładowo jakiś literał, to w oknie przeglądarki element zajmie najmniejszą potrzebną mu
					wysokość - w tym przypadku jeden wiersz. Jeśli natomiast zawartość elementu jest większa niż wartość
					max-height, np. jest to wiele linijek tekstu, to element wyświetli się w maksymalnie określonej
					wysokości, natomiast jego zawartość będzie wykraczać poza przewidzianą dla elementu przestrzeń.
				</p>
				<img class="image" src="/max-height.jpg"
					alt="Przykład treści ostylowanej za pomocą wartości max-height, gdy zawartość elementu jest wyższa i wystaje poza element." />
				<p class="article__paragraph">min-width</p>
				<p class="article__paragraph">
					Jeśli ustalimy minimalną szerokość większą niż dostępna szerokość okna, to pojawi się
					scroll, który pozwoli na dostanie się do niedostępnej części elementu.
				</p>
				<p class="article__paragraph">min-height</p>
				<p class="article__paragraph">
					Jeśli ustalimy minimalną wysokość dla elementów, to te elementy, których zawartość
					nie przekracza ustalonej wysokości minimalnej będą miały taką wysokość, jak zdefiniowana minimalna.
					Jeśli natomiast zawartość elementu ma większą wysokość niż zdefiniowana minimalna, to element
					przyjmie
					taką wysokość, jaka jest potrzebna, by zmieścić zawartość.
				</p>
			</article>
			<article class="article">
				<h3 class="article__header">Overflow</h3>
				<p class="article__paragraph">
					Własność overflow definiuje, jak ma zachować się element w sytuacji, gdy treść za niego wystaje.<br>
				</p>
				<p class="article__paragraph">overflow: hidden</p>
				<p class="article__paragraph">
					Ukrywa całą treść, która nie mieści się w elemencie, ucina wszystko, co
					wystaje poza jego zdefiniowaną wysokość i szerokość.
				</p>
				<p class="article__paragraph">overflow: auto</p>
				<p class="article__paragraph">
					W sytuacji, gdy zawrtość elementu jest wyższa niż element, własność overflow o
					wartości auto dodaje wewnątrz elementu scrolla, który pozwala na dostęp do całej treści zawartej w
					elemencie.
				</p>
				<img class="image" src="/overflow-auto.jpg"
					alt="Przykład treści ostylowanej za pomocą własności overflow: auto." />
				<p class="article__paragraph">overflow: clip</p>
				<p class="article__paragraph">
					Na naszym obecnym przykładzie zachowuje się jak overflow:hidden, ale gdy
					stylujemy nasze strony w bardziej zaawansowany sposób, to wykorzystujemy w sytuacji, gdy pewne
					elementy
					chcemy tak wypozycjonować, by wykraczały poza nasze body.
				</p>
				<p class="article__paragraph">overflow: scroll</p>
				<p class="article__paragraph">
					Dodawany jest scroll do wszystkich elementów ostylowanych w ten sposób,
					niezależnie od wysokości i szerokości. Nie we wszystkich elementach scroll będzie działać, a jedynie
					w
					tych, w przypadku których zawartość elementu wykracza poza określoną dla niego wysokość lub
					szerokość. W
					przypadku overflow: auto, scroll dodawany jest tylko tam, gdzie jest naprawdę potrzebny.
				</p>
				<img class="image" src="/overflow-scroll.jpg"
					alt="Przykład treści ostylowanej za pomocą własności overflow: scroll." />
				<p class="article__paragraph">overflow: visible</p>
				<p class="article__paragraph">
					Powoduje, że treść, która wykracza poza dostępną wysokość lub szerokość
					elementu nie jest ukrywana, ale wystaje za element. Jeśli za elementem, z którego wystaje treść,
					umieścimy kolejny, w którym określona dla niego zawrtość się mieści, to element ten dodawany jest od
					razu za poprzedzającym go elementem. Przestrzeń nie jest rezerowana na niemieszczącą się treść. W
					takiej
					sytuacji treści obu elementów mogą się na siebie nakładać.
				</p>
				<img class="image" src="/overflow-visible.jpg"
					alt="Przykład treści ostylowanej za pomocą własności overflow: visible." />
			</article>
			<article class="article">
				<h3 class="article__header">Jednostki</h3>
				<p class="article__paragraph">Piksele</p>
				<p class="article__paragraph">
					Wartość 0 możemy zapisywać bez jednostek. Nie ma znaczenia, czy są to piksele, procenty czy jeszcze
					coś
					innego, zapisujemy po prostu 0.<br>
					Piksele zapisujemy jako px, piksel jest to po prostu punkt na ekranie. Jednostke zapisujemy razem z
					liczbą, bez spacji, np. 200px, w przeciwnym razie to nie zadziała. Piksel jako jednostka nie ma
					przełożenia na gęstość pikselową ekranów. Piksele określające np. rozdzielczość HD składają się na
					większe piksele, które stosowane są jako jednostki. To, że rozdzielczość ekranów zmienia się, składa
					się
					na nią coraz większa liczba pikseli, poprawiając jakość obrazu, nie wpływa na zmianę wielkości
					piskeli
					jako jednostek, które wciąż pozostają takie same. Przeglądarka sobie to poprawnie przelicza.
				</p>
				<p class="article__paragraph">Procenty</p>
				<p class="article__paragraph">
					Procenty zapisujemy jako %, również bez spacji, np. 50%. Wartość ta musi mieć jakiś punkt
					odniesienia,
					rodzica, w naszym przypadku będzie to po prostu body. Jeśli podamy dla elementu szerokość 50%, to
					będzie
					on zajmował połowę dostępnego okna przeglądarki. W przypadku wysokości natomiast nie jest to już tak
					proste, bo rodzic nie ma domyślnej wartości, do której moglibyśmy się odnieść, a wysokość okna
					zależy od
					zawartości elementów, co może być zmienne. Jeśli chcemy wysokość jakiegość elementu określić
					procentowo,
					to musimy zdefiniować wysokość dla wszystkich elementów nadrzędnych, w których dany element jest
					zagnieżdżony. W przypadku div'a zagnieżdżonego bezpośrednio w body, aby określić jego procentową
					wysokość, musimy określić wysokość body oraz naszego root'a, czyli html np. jako 100% albo w
					pikselach.
					Generalnie jednak nie definiujemy wysokości w ten sposób jak na podanym przykładzie, jest to bardzo
					ekstremalny przypadek.
				</p>
				<img class="image" src="/height-in-percent.jpg"
					alt="Przykład treści ostylowanej za pomocą wysokości zdefiniowanej w procentach." />
				<p class="article__paragraph">
					Jeśli natomiast będziemy mieć element zawarty w innym elemencie, którego wysokość i szerokość
					zostały
					zdefiniowane, do nadając temu zagnieżdżonemu elementowi wysokość i szerokość o wartości 50%, zajmie
					on
					połowę wysokości i szerokości rodzica, a nie całego body.
				</p>
				<p class="article__paragraph">Viewport width i viewport height</p>
				<p class="article__paragraph">
					Viewport width (vw) jest to jednostka odnosząca się do szerokości okna, w którym wyświetla się nasz
					dokument. Jednostka ta zawsze działa w kontekście szerokości całego ekranu, czyli nawet jeśli mamy
					element zagnieżdżony w innym elemencie o określonej szerokości, to nadając temu zagnieżdżonemu
					elementowi szerokość 50vw, zajmie on połowę dostępnego ekranu, a nie połowę szerokości rodzica.<br>
					W przypadku jednostki viewport height (vh) jej zastosowanie nie powoduje takich problemów jak
					definiowanie wysokości w procentach. Jednostka vieport height bazuje na wysokości dostępnego okna, w
					którym wyświetla się treść, a nie wysokości całego dokumentu. Czyli jeśli wysokość elementu
					zdefiniujemy
					na 33vh, to zajmie on 33% dostępnego okna przeglądarki. Jeśli natomiast wysokość elementu
					zdefiniujemy
					na 100vh, to zajmie on 100% dostępnego okna przeglądarki i by dostać się do treści spoza elementu,
					będziemy musieli się przescrollować. Można w ten sposób np. wykonać pokaz slajdów na stronie.
				</p>
			</article>
			<article class="article">
				<h3 class="article__header">Box model: padding, border i margin</h3>
				<p class="article__paragraph">
					Wszystkie elementy na stronie internetowej otoczone są niewidzialnym prostokątem, który ma jakąś
					wysokość i szerokość i który możemy podejrzeć, najeżdżąjąc na te elementy za pomocą devtools. Box
					model jest to zatem opis wymiarów naszego elementu, który składa się z kilku wartości:<br>
					- element - znajduje się w środku i ma określoną wysokość i szerokość;<br>
					- padding - jest to wewnętrzny margines, który definiuje, jaka ma być odległość między treścią,
					zawartością naszego elementu a ramką tego elementu;<br>
					- border - ramka elementu, zamyka element;<br>
					- margin - nie jest już częścią elementu, ale definiuje jego zachowanie, określa o ile nasz element
					ma być oddalony od innych elementów i o ile te inne elementy mają być oddalone od naszego
					elementu.<br>
					Box model dla danego elementu można podejrzeć w devtools. Wartości są tam opisane w pikselach.<br>
				</p>
				<img class="image" src="/box-model.jpg"
					alt="Box model składający się z elementu, paddingu, borderu i marginu." />
				<p class="article__paragraph">Padding</p>
				<p class="article__paragraph">
					Padding, czyli wewnętrzny margines, jest własnością, która posiada kilka wartości. Można go opisać w
					sposób pełny, podając odległość od treści elementu od ramki po stronie lewej, prawej oraz od góry i
					dołu, opisując każdą z wartości osobno i definiując je w sposob jawny. Można również dokonać zapisu
					skrótowego (shorthand), bez opisywania każdej strony osobno, podając same wartości dla paddingu
					według
					określonej kolejności, zgodnie z ruchem wskazówek zegara: góra prawo, dół, lewo. Jeśli natomiast
					padding
					będzie miał przypisaną tylko jedną wartość, to będzie ona miała zastosowanie do wszystkich czterech
					stron. Innymi słowy, jeśłi wszystkie wartości paddingu są takie same, to wystarczy opisać padding za
					pomocą tej jednej wartości (np. padding: 10px), bez wyszczególniania padding-bottom, padding-top,
					padding-left, padding-right.
				</p>
				<img class="image" src="/padding-description.jpg"
					alt="Przykład zapisu pełnego i skróconego dla paddingu." /> <br>
				<p class="article__paragraph">
					Padding można opisać również za pomocą tzw. wartości lustrzanych, jeśli chcemy, by wartości góra/dół
					oraz prawo/lewo, były takie same. Możemy podać w takiej sytuacji dla paddingu tylko dwie wartości i
					wówczas zostaną one dobrane parami - pierwsza zostanie przypisana do odległości góra/dół, z kolei
					druga
					dla stron prawo/lewo.
				</p>
				<img class="image" src="/padding-mirror-values.jpg"
					alt="Przykład zapisu wartości lustrzanych dla paddingu." />
				<p class="article__paragraph">Border</p>
				<p class="article__paragraph">
					Podobnie jak padding, border również może być opisany w sposób pełny i zawierający definicje
					wszystkich
					własności lub w sposób skrótowy (shorthand), gdzie wszytskie wartości są wrzucone do jednej
					własności o
					nazwie border. Border może być opisany za pomocą wartości:<br>
					- border-width - opisuje szerokość ramki;<br>
					- border-style - opisuje styl ramki, wartość ta musi być podana, by ramka się w ogóle pojawiła;<br>
					- border-color - opisuje kolor ramki.<br>
					Jeśli dany element zostanie ostylowany podwójnie, np. za pomocą opisu pełnego i skrótowego, gdzie
					będą
					podane różne wartości, to zgodnie z ogólnymi regułami specyficzności, zastosowanie będzie miał styl
					znajdujący się niżej w pliku, czyli ten, który de facto jest bliżej danego elementu.<br>
					Ramka nie musi znajdować się po każdej ztronie elementu, możemy sobie zdefiniować, po której stronie
					chcemy ją umieścić, opisując ją za pomocą wartości border-bottom, border-left, border-top,
					border-right,
					definiując tylko tę stronę, po której chcemy mieć ramkę. Jeśli natomiast damy definicję ogólną dla
					border, to style poszczególnych stron ramki możemy sobie nadpisywać dodając definicje np. dla
					border-top
					i border-bottom. W podanym przykładzie ramka po stronie lewej i prawej będzie ostylowana według
					definicji ogólnej, natomiast góra i dół ramki zostaną ostylowane według definicji szczegółówych
					określonych w sposób jawny dla border-bottom i border-top.
				</p>
				<img class="image" src="/border-description.jpg"
					alt="Własność border opisana w sposób pełny i skrótowy." />
				<p class="article__paragraph">
					Do ramki można dodać również efekt zaokrąglenia za pomocą wartości <strong>border-radius</strong>.
					Żeby
					skorzystać z tego efektu nie musimy wcale mieć definicji dla ramki - w takiej sytuacji zaokrąglony
					zostanie sam element. Border-radius opisujemy za pomocą pikseli lub procentów. Jeśli określimy, ze
					border-radius: 100%, to dany element zostanie zaokrąglony na całej długości i szerokości.
					Border-radius
					można również wykorzystać do zrobienia kółka za pomocą CSS. Aby uzyskać taki efekt, element musi
					mieć
					taką samą wysokość i szerokość i definiujemy dla niego border-radius: 100%.
				</p>
				<img class="image" src="/border-radius.jpg"
					alt="Przykłady elementów ostylowanych za pomocą własności border-radius." />
				<p class="article__paragraph">Margin</p>
				<p class="article__paragraph">
					Marginesy zapisujemy tak samo jak padding. Marginesy zewnętrzne nakładają się na siebie, co oznacza,
					że
					jeśli mamy obok siebie dwa elementy i dla jednego zdefiniujemy margin: 100px, a dla drugiego margin:
					120px, to odległość między tymi elementami wyniesie 120px, a nie 220px. Dla marginesów występują
					również
					wartości lustrzane, które wykorzystywane są często by wyśrodkować dany element. By uzyskać taki
					efekt do
					własności margin dodajemy dwie wartości - odstęp oraz auto, np. margin: 50px auto. Jeśli element
					zajmuje
					całą dostępną szerokość okna, to będzie po prostu oddalony o krawędzi okna o wartość zdefiniowaną
					dla
					margin, jeśli jednak szerokość elementu jest mniejsza niż dostępne okno przeglądarki, to wartość
					auto
					sprawi, że element zostanie wyśrodkowany. Jeśli dany element jest zagnieżdżony w innym divie, to w
					takim
					przypadku będzie centrowany nie do dostępnego okna, ale w ramach swojego rodzica, nadrzędnego diva.
				</p>
				<img class="image" src="/margin-auto.jpg"
					alt="Element wyśrodkowany za pomocą wartości auto zdefiniowanej dla marginesu." />
			</article>
			<article class="article">
				<h3 class="article__header">Box sizing - content-box versus border-box</h3>
				<p class="article__paragraph">
					Domyślny box sizing to content-box, czyli definicja szerokości i wysokości elementu odnosi się do
					samego contentu, nie obejmuje paddingu i borderu. Jeśli zatem zmniejszymy lub zwiększymy padding
					i/lub border, to wpłynie to również na wielkość samego elementu.<br>
					Box sizing może być jednak również określany przez wartość border-box, gdzie definicja wysokości i
					szerokości elementu odnosi się do całego elementu i oprócz contentu obejmuje również padding i
					border. Aby było to możliwe, należy dla danego elementu lub grupy elementów dodać własność
					box-sizing: border-box. Definiowanie wielkości elementów w ten sposób pozwala przewidzieć, jak duży
					będzie element, bez względu na to, jaką wartość będzie miał jego padding czy border. Wielkość
					contentu elementu jest tu wyliczana automatycznie, po odjęciu od wysokości i szerokości całego
					elementu, wartości paddingu i borderu. Wartość border-box jest obecnie stosowana jako rozwiązanie
					standardowe dla określania box sizing.<br>
					Zarówno w przypadku content-box, jak i border-box, wielkość marginesu nie wpływa na wielkość
					elementu, gdyż margines znajduje się już poza elementem.
				</p>
				<img class="image" src="/box-sizing.jpg"
					alt="Porównanie elementów określonych za pomocą content-box i border-box." />
				<p class="article__paragraph">
					Jeśli mamy dwa elementy, z których jeden jest ostylowany za pomocą border-box, a drugi za pomocą
					content-box i chcemy, by oba miały taką samą wysokość i szerokość równą 200px, padding o wartości
					40px i border równy 20px, to w przypadku elementu ostylowanego za pomocą box-sizing: border-box,
					wystarczy, że określimy dla tego elementu width i height, definiując dla nich wartość 200px i podamy
					wartości dla padding i border zgodne z powyższymi. Z kolei element ostylowany za pomocą box-sizing:
					conent-box, który ma padding równy 40px i border równy 20px, by uzyskać wielkość 200px, musi mieć
					wysokość i szerkość 80px (80px sam conent plus 2x40px paddingu i 2x20px borderu daje w sumie 200px
					dla całego elementu).
				</p>
			</article>
			<article class="article">
				<h3 class="article__header">Position i float</h3>
				<p class="article__paragraph">Position: static</p>
				<p class="article__paragraph">
					Własność position: static oznacza, że to przeglądarka decyduje, gdzie dany element umieścić,
					wyliczając
					to sobie na podstawie zdefiniowanych stylów dla elementów na stronie (czy blok, czy inline,
					odległości,
					etc.). Jest to wartość domyślna, znajduje zastosowanie, gdy nie ma określonej wprost wartości dla
					position. Można ją jednak również określić jawnie.
				</p>
				<p class="article__paragraph">Position: relative, position: absolute</p>
				<p class="article__paragraph">
					Własność position: relative pozwala na stworzenie przestrzeni, względem której możemy umieszczać
					inne
					elementy. Po dodaniu tego stylu wygląd elementu się nie zmienia, ale stworzona za jego pomocą
					przestrzeń
					umożliwia wykorzystanie własności position: absolute.<br>
					Position: absolute pozwala na pozycjonowanie względem elementu, który ma zdefiniowaną pozycję
					relative.
					Element z pozycją absolute może być przesuwany po stworzonej warstwie względem rodzica, który jest w
					pozycji relative za pomocą wartości top, right, bottom, left. Pozycja jest liczona od krawędzi
					elementu,
					nie uwzględniając bordera.
				</p>
				<img class="image" src="/position-absolute.jpg"
					alt="Przykład elementu ostylowanego za pomocą position: absolute." />
				<p class="article__paragraph">z-index</p>
				<p class="article__paragraph">
					Jeśli dwa elementy mają zdefiniowaną tę samą pozycję, to widoczny na wierzchu jest ten, którego
					definicja stylu znajduje się bliżej końca pliku, czyli ten, który renderuje się później
					(renderowanie -
					proces przekształcania kodu i danych w finalną postać, która jest widoczna i interaktywna dla
					użytkownika. Polega na konwersji abstrakcyjnych danych w konkretne elementy graficzne lub wizualne
					reprezentacje). W takiej sytuacji umiejscowieniem elementu można sterować za pomocą własności
					z-index,
					która odpowiada za warstwowanie - im wyższa wartość z-index, tym dany element jest wyżej. Do
					pozycjonowania staramy się używać sensownych, niezbyt dużych liczb (np. z-index: 10;) i zwiększać je
					powoli. Wóczas zastosowanie dużej liczby, np. 1000 sprawi, że elementy wypozycjonowane niżej znajdą
					się
					pod spodem i nie będą zasłaniały wybranego elementu.
				</p>
				<img class="image" src="/z-index.jpg"
					alt="Przykład warstwowania elementów za pomocą własności z-index." />
				<p class="article__paragraph">
					Warstwowanie elementów na stronie jest dobrze zobrazowane w przeglądarce Edge. Po uruchomieniu w
					devtools za pomocą skrótu ctrl + shift + p panelu wyszukiwania należy wpisać i wybrać '3d view' i
					wówczas pojawi się zakładka, w której możemy podejrzeć naszą stronę w ujęciu trójwymiarowym. Widok
					można
					obracać stosując strzałki widoczne w oknie. Jedną z opcji widoku jest z-index, gdzie można podejrzeć
					jak
					elementy układają się na warstwach według zdefiniowanych wartości z-index.
				</p>
				<img class="image" src="/3Dview.jpg"
					alt="Widok okna 3d view w narzędziach developerskich na przeglądarce Chrome." />
				<p class="article__paragraph">
					Panel 3D view posiada również zakładkę DOM, w której można podejrzeć zagnieżdżenia elementów na
					stronie
					w ujęciu trójwymiarowym, czyli jak strona jest zbudowana.
				</p>
				<p class="article__paragraph">Position: fixed</p>
				<p class="article__paragraph">
					Własność position o wartości fixed pozwala na przyklejenie elementu do viewportu, czyli widocznego
					okna
					przeglądarki. Ostylowany w ten sposób element wyskakuje z pudełka i przykleja się w zdefiniowanym
					miejscu przeglądarki. Jeśłi nadamy takiemu elementowi dodatkowo z-index o wartości ujemnej, np. -1,
					to
					scrollując treści w oknie przeglądarki, będzie on się cały czas przesuwał, by być widoczny w
					viewport,
					ale będzie się chował pod innymi elementami, które domyślnie mają przypisaną wartość z-index: 0.
					Wartość
					fixed jest często używana w urządzenianiach mobilnych, np. do przyklejenia przycisku menu.
				</p>
				<img class="image" src="/position-fixed.jpg"
					alt="Przykład ostylowania elementu za pomocą własności position: fixed." />
				<p class="article__paragraph">Position: sticky</p>
				<p class="article__paragraph">
					Wartość sticky jest bardzo przydatna, np. gdy mamy dłuższe treści i chcemy przykleić nagłówek
					wewnątrz
					danego kontenera. Należy mieć jednak na uwadze, że styl sticky nie zadziała, jeśli rodzic danego
					elementu ostylowanego w ten sposób ma przypisaną własność overflow. Dodatkowo, element, któremu
					nadajemy własność sticky musi zostać jakoś umiejscowiony w kontenerze względem viewport, np. za
					pomocą
					własności top: 0. W tym przypadku element sticky przyklei się do góry strony i gdy będziemy
					scrollować
					stronę, zostanie cały czas w tym samym miejscu aż do momentu, gdy wyjdziemy z danego elementu
					rodzicielskiego, wówczas nie będzie się już dalej przesuwał i zniknie z viewport razem z całym
					kontenerem. Sticky bowiem działa tylko wewnątrz danego rodzica. Można go wykorzystać np. gdy mamy
					dłuższy tekst i chcemy, by nagłówki się przyklejały w pewnym momencie przy scrollowaniu dalszej
					części
					tekstu. Odległość od góry strony można oczywiście określić według potrzeb.
				</p>
				<img class="image" src="/position-sticky.jpg"
					alt="Przykład ostylowania elementu za pomocą własności position: sticky." />
				<p class="article__paragraph">
					Do niedawna, zanim powstała własność position: sticky, ten sposób ostylowania elementu trzeba było
					kodować w JS. Ponadto, w odróżnieniu od wartości absolute, która żyje swoim życiem i nie zmienia
					treści
					elementu, wartość sticky stanowi element treści i zachowuje się tak, jak cała reszta treści, dopóki
					nie
					zaczniemy scrollować. W związku z tym nie musimy podawać dla sticky dodatkowych paddingów i
					marginesów,
					Przeglądarka sama sobie to wyliczy. Wystarczy podać jakąś wartość top, a w przypadku stron
					scrollowanych
					w poziomie, jakąś odległość left lub right.
				</p>
				<p class="article__paragraph">Float</p>
				<p class="article__paragraph">
					Element ostylowany za pomocą wartości float zachowuje się w ten sposób, że jest opływany przez
					treść,
					która znajduje się po nim. Float może przykleić nasz element do lewej strony (float: left;) lub
					prawej
					(float: right;).
					Kiedyś stylowanie za pomocą float było bardzo popularne jako technika budowania stron internetowych,
					ale
					obecnie Maciek go nie rekomenduje. Można go wykorzystać do rozrzucania tekstu np. do wrzucenia w
					treść
					obrazka, ostylowania jakiegoś obrazka w taki sposób, by był opływany przez tekst. <strong>Float nie
						służy do budowania layoutów.</strong> Obecnie wykorzystywane są do tego nowoczesne techniki,
					które
					będą omówione później.
				</p>
				<img class="image" src="/float.jpg" alt="Elementy ostylowane za pomocą własności float." />
				<p class="article__paragraph">Clear</p>
				<p class="article__paragraph">
					Własność clear czyści nam floaty. Jeśli do kontenera div, w którym znajdują się elementy mające
					zdefiniowaną własność float, dodamy kolejnego diva ostylowanego za pomocą własności clear, to
					wyczyści
					on floaty zdefiniowane w ramach tego samego diva rodzicielskiego (clear: both). Elementy o wartości
					float nadal będą przyklejone do lewej lub prawej, ale tekst spadnie poniżej. Sam div ostylowany za
					pomocą clear nie jest widoczny bezpośrednio na stronie, wpływa jedynie na inne elementy.
				</p>
				<img class="image" src="/clear.jpg" alt="Przykład użycia własności clear." />
			</article>
			<article class="article">
				<h3 class="article__header">Normalizacja vs reset</h3>
				<p class="article__paragraph">Domyślne style przeglądarki</p>
				<p class="article__paragraph">
					Normalizacja i reset to metody ujednolicania stylów. Przeglądarki internetowe posiadają bowiem swoje
					style domyślne, które nadają wszystkim elementom na stronie. Można je podejrzeć w devtools, na
					przykładzie poniżej są opisane jako "user agent stylesheet".
				</p>
				<img class="image" src="/browser-default-styles.jpg"
					alt="Podgląd domyśnych stylów przeglądarki w devtools." />
				<p class="article__paragraph">Reset</p>
				<p class="article__paragraph">
					Reset jest pierwszą z technik, która powstała, by ujednolicić style. Kod umieszczamy w znaczniku
					style, który dodajemy w sekcji head w tym miejscu, gdzie linkuje się plik ze stylami. Jako selektor
					podajemy gwiazdkę *, która odnosi się do wszystkich elementów na stronie i dla wybranych własności
					podajemy wartość zero 0 (margin, padding) lub none (outline, listy). Na obrazku poniżej przy outline
					o wartości none jest przerażona emotka, gdyż Maciek uważa dodawanie tej własności w reset jako
					dziwną praktykę. Wyłączenie outline powoduje bowiem, że przy przechodzeniu klawiaturą przez elementy
					klikalne na stronie, element, na którym w danym momemncie jest fokus, nie jest zaznaczony. Praktyka
					ta może zatem budzić wątpliwości w kontekście dostępności strony. Maciek zaleca więc, by parametru
					outline nie resetować.<br>
					Niektórzy do resetu dodawali jeszcze własność font-size o wartości 16px. Obecnie jednak od
					stosowania resetu już się odchodzi.
				</p>
				<img class="image" src="/styles-reset.jpg"
					alt="Kod do ujednolicania domyślnych stylów przeglądarki za pomocą metody reset." />
				<p class="article__paragraph">Normalizacja</p>
				<p class="article__paragraph">
					Normalizacja jest kolejną metodą, która powstała, by znormalizować, ujednolicić style między
					przeglądarkami, ponieważ każda z przeglądarek może nieco inaczej interpretować i wyświetlać elementy
					na stronie, posiadać dla nich inne style domyślne. Dzięki temu punkt wyjścia dla stylów we
					wszystkich przeglądarkach jest taki sam.<br>
					W celu normalizacji stylów w przeglądarkach powstał projekt normalize.css, który tworzy standard i
					wytyczne dla ujednolicania stylów między przeglądarkami. Wystarczy wejść na stronę projektu np. na
					github, pobrać kod i skopiować go w całości do pliku normalize.css, który dodajemy do projektu.
					Treści pliku nie musimy edytować, możemy dodać go tak, jak jest. Następnie linkujemy ten plik w
					sekcji head w plikach HTML-owych w projekcie za pomocą znacznika link, tak samo jak plik ze stylami
					style.css.<br>
					Do pliku normalize.css można również dodać defnicję własności box-sizing: border-box, czyli
					stosowany obecnie standard, w ramach którego padding i border wliczane są do wielkości elementu. Z
					uwagi jednak na to, że w razie aktualizacji standardu normalizacji i wklejeniu nowego kodu,
					definicja ta mogłaby zostać z rozpędu wycofana, lepiej zawrzeć ją w pliku ze stylami, zakotwiczając
					ją na selektorze elementu html. Następnie dodajemy jeszcze dziedziczenie własności box-sizing z tego
					elementu we wszystkich pozostałych elementach na stronie, zakotwiczając się na selektorach *,
					*:before i *:after, które w definicji stylu wymieniamy po prostu po przecinku, by nie powtarzać kodu
					trzykrotnie, osobno dla każdego z nich.<br>
				</p>
				<img class="image" src="/normalize-box-sizing.jpg" alt="Kod do normalizacji własności box-sizing." />
			</article>
			<article class="article">
				<h3 class="article__header">BEM - block element modifier</h3>
				<p class="article__paragraph">
					BEM to sposób nazywania klass CSS, który wprowadza porządek do projektu. Jest to odpowiedź na wysoki
					stopień skomplikowania stylowania oraz brak ujednolicenia jego stosowania. Pozwala ponadto na
					odwzorowanie struktury HTML w CSS poprzez nadawanie nazwom klas sensu semantycznego.
				</p>
				<ul class="unordered-list">
					<li class="unordered-list__element">Block - nadrzędny element.</li>
					<li class="unordered-list__element">Element - część bloku, nie musi być bezpośrednim dzieckiem, może
						być zagnieżdżona głębiej, ale musi się odnosić w jakiś logiczny sposób do elementu nadrzędnego
						jeśli chodzi o nazewnictwo.</li>
					<li class="unordered-list__element">Modifier - modyfikator, jeśli element występuje w kilku
						wariantach, to tworzymy dla nich dodatkową klasę.</li>
				</ul>
				<img class="image" src="/bem-hand.jpg"
					alt="Przedstawienie modelu stylowania BEM na przykładzie dłoni." />
				<p class="article__paragraph">
					Stosując model stylowania za pomocą BEM, należy wybrać jakąś logiczną część struktury naszej strony
					i nadać jej główną klasę, na powyższym przykładzie jest to właśnie dłoń (.hand). Wszystkie dzieci w
					ramach tego elementu w swojej nazwie klasy odnoszą się do klasy rodzica, zawierając część jego nazwy
					(.hand__finger). Niektóre z tych dzieci mają dodatkowo klasę modyfikującą (.hand__finger--pinky),
					wyróżniającą je spośród innych. Palce te dzielą wszystkie te własności, które mają pozostałe palce,
					ale mają dodatkowo swoje własności specjalne, co zostało odzwierciedlone właśnie poprzez nadanie
					dodatkowej klasy. Innymi słowy, jeśłi element posiada modyfikator, to opisujemy go za pomocą dwóch
					klas.<br>
					Na obrazku poniżej przykład ten został przełożony na kod HTML.
				</p>
				<img class="image" src="/bem-hand-html.jpg"
					alt="Przedstawienie modelu stylowania BEM na przykładzie dłoni w przełożeniu na kod HTML." />
				<p class="article__paragraph">
					Model stylowania BEM na przykładzie artykułu na stronie internetowej.
				</p>
				<img class="image" src="/bem-article.jpg"
					alt="Przedstawienie modelu stylowania BEM na przykładzie artykułu na stronie internetowej." />
				<p class="article__paragraph">
					Model stylowania BEM na przykładzie artykułu na stronie internetowej po przełożeniu na kod HTML.
				</p>
				<img class="image" src="/bem-article-html.jpg"
					alt="Przedstawienie modelu stylowania BEM na przykładzie artykułu w przełożeniu na kod HTML." />
				<p class="article__paragraph">
					Style CSS według modelu BEM również definiuje się w sposób uporządkowany, wychodząc od elementu
					nadrzędnego i przechodząc po kolei przez elementy, które znajdują się w jego strukturze BEM. Należy
					pamiętać, żeby modyfikatory umieszczać na dole danej struktury BEM w pliku ze stylami, żeby były jak
					najbliżej elementów, których style wyróżniają, żeby nie zostały nadpisane przez style zdefiniowane
					dla ich elementów nadrzędnych. W modyfikatorze zmieniamy tylko unikalne dla niego wartości, nie
					przepisujemy definicji stylów z klasy bazowej.<br>
					Poniżej znajduje się przykład modelu stylowania BEM na przykładzie artykułu na stronie internetowej
					po przełożeniu na kod CSS.
				</p>
				<img class="image" src="/bem-article-css.jpg"
					alt="Przedstawienie modelu stylowania BEM na przykładzie artykułu w przełożeniu na kod CSS." />
			</article>
		</section>
		<section class="section">
			<h2 class="section__header">CSS - tydzień 5</h2>
			<article class="article">
				<h3 class="article__header">Typografia</h3>
				<p class="article__paragraph">
					Własność font-size, odnoszącą się do rozmiaru tekstu na stronie, można definiować za pomocą różnych
					jednostek:
				</p>
				<ul class="unordered-list">
					<li class="unordered-list__element">piksel</li>
					<li class="unordered-list__element">rem</li>
					<li class="unordered-list__element">em</li>
				</ul>
				<p class="article__paragraph">
					Własność font-family odpowiada za krój czcionki, jej wygląd. Domyślne wartości, jakie prezglądarka
					nadaje tekstowi można podejrzeć w devtools Elelemts - Computed - zaznaczone 'group' - zaznaczone
					'show all' - zwinięcie innych sekcji i rozwinięcie sekcji 'text'. W przypadku Chrome, domyślna
					własność font-family to Times New Roman. Aby ustawić własny krój czcionki dla całej strony,
					najlepiej zrobić to na tagu body. Przy definiowaniu czcionki, VSC podpowiada co do zasady bezpieczne
					wartości font-family, czyli takie, które działają na większości systemów. Jeśli danego fontu nie ma,
					to po przecinku wypisane są alternatywy, które będą miały wówczas zastosowanie (np. Verdana, Geneva,
					Tahoma, sans-serif). Można oczywiście wykorzystać również czcionkę, której nie m na liście
					pdpowiedzi w VSC.Jeżeli font ma w nazwie spację, to musi być podany w apostrofach. Czcionki mogą
					mieć przypisane wartości:
				</p>
				<ul class="unordered-list">
					<li class="unordered-list__element">monospace - oznacza, że każda litera zajmuje tyle samo miejsca;
						wykorzystywana raczej do nagłówków lub do pisania kodu;</li>
					<li class="unordered-list__element">serif - czcionki szeryfowe, zawierające elementy dekoracyjne
						przy literach;używane zwykle do tekstów drukowanych;</li>
					<li class="unordered-list__element">sans-serif - pismo bezszeryfowe, o kroju pozbawionym ozdobników
						w postaci szeryfów (końcówki znaków są proste), krój taki uznawany jest za bardziej nowoczesny.
					</li>
				</ul>
				<p class="article__paragraph">
					W devtools można podejrzeć czcionki, które się wyrenderowały i wyświetliły na stronie.
				</p>
				<p class="article__paragraph">
					Własność font-weight definiuje grubość czcionki. Po wpisaniu tej własności w pliku ze stylami w VSC,
					edytor podpowiada dostępne opcje w formie numerycznej, od najcieńszej 100 do najgrubszej 900. Są
					również dostępne opcję w formie opisowej, np. bold, bolder, lighter, normal. Standardowa grubość
					czcionki, font-weight normal, to 400, a bold to najczęściej 700. Zależy to jednak od rodzaju
					czcionki, nie wszystkie wspierają wszystkie grubości. Obecnie już raczej nie operujemy wartościami
					słownymi, tylko numerycznymi.
				</p>
				<p class="article__paragraph">
					Własność line-height odpowiada za wyskość tekstu. Wysokość fontu w przeglądarce ma zwykle 16px.
					Domyślny przeglądarkowy line-height jest zwykle trochę większy i wynosi około 18,5px. Zwykle
					definiuje się go na nieco większy. Jeśli nadamy mu wartość line-height: 1,5, bez żadnej jednostki,
					to wyniesie on 150% wysokości czcionki., dla czcionki o wysokości 16px, będą t0 24px.
				</p>
				<p class="article__paragraph">
					Własność letter-spacing określa odległość między literami. Nietypowe wartości można wykorzystać np.
					w nagłówkach. Letter-spacing można podać w różnych jednostkach, np. w pikselach. Można używać
					wartości ujemnych (np. -0.2px, -2px), wówczas litery zaczną na siebie nachodzić. Wartość definiujemy
					zależnie od tego, jaki efekt artystyczny chcemy osiągnąć i co widzimy na stronie.
				</p>
				<p class="article__paragraph">
					Przy stylowaniu tesktów wykorzystujemy znacznik span - nie ma on znaczenia semantycznego, jest jak
					div, tylko odnosi się do tekstów, np. w danej linii, a nie całych większych kontenerów. Span pozwala
					na tworzenie wyróżników wizualnych dla treści na stronie, które chcemy wyróżnić graficznie, ale
					których nie ma sensu wyróżniać semantycznie. Opakowujemy sobie w takiej sytuacji wybrane treści w
					znacznik span o określonej klasie i definiujemy dla tej klasy wybrane style.
				</p>
				<p class="article__paragraph">
					Jednostka EM ma swoje korzenie w wysokości czcionek drukarskich w czasach, gdy były osadzone na
					prostokątnych elementach. 1 em odpowiada wartości font-size, jaka została zdefiniowana lub
					odziedziczona przez dany element, pomnożonej przez 1. Za pomocą emów możemy definiować rozmiar
					czcionki, ale też inne własności, np wysokość. Jeśli przykładowo dla nagłówka określimy sobie
					font-size" 10px i damy temu nagłówkowi wysokość równą 10em, to sam literał nagłówka będzie miał
					10px, ale cały element 100px (10px*10em). Emy są dość problematyczne, bo nie zawsze możemy
					przewidzieć jaka ta jednostka jest dla danego elementu. Świetnie sprawdzają się jednak dla takich
					własności jak letter-spacing, gdzie jeśli rozmar czcionki będzie rósł, to letter-spacing () będzie
					się również proporcjonalnie zmieniać. Na przykładzie prezentowanym przez Maćka letter-spacing
					określony jest jako wartość ujemna -0.05em, stanowiąca procent wartości font-size ustawionej na
					naszym elemencie.
				</p>
				<img class="image" src="/em-definition.jpg" alt="Definicja jednostki em." />
				<img class="image" src="/em-example.jpg"
					alt="Przeliczenie wartości em na piksele na przykładzie nagłówka." />
				<p class="article__paragraph">
					Jednostka REM - R z przodu odpowiada root elementowi naszego HTMLa, czyli 1rem to font-size dla
					naszego root elementu pomnożony przez 1. (Root elementem, czyli elementem bazowym nazywamy znacznik
					HTML, w którym zawiera się cała treść strony.) 1rem to zwykle 16px, 2rem to 32px, 0.5rem to 8px,
					etc. gdyż w domyślnych stylach, jakie przeglądarka zwykle nadaje czcionkom, font-size wynosi 16px.
					Zatem jeśli ustawimy sobie styl dla nagłówka, nadając czcionce wartość 2rem, to mimo, że rodzicu
					tego elementu font-size będzie ustawiony na 10px, to nagłówek będzie miał 32px, gdyż odwołujemy się
					tu bezpośrednio do root elementu naszego HTMLa, a nie rodzica. Jeśli jednak w sposób jawny
					zdefiniujemy dla znacznika html font-size i nadamy mu wartość np. 20px, to w takim przypadku 1rem
					będzie wynosił 20px, 2rem natomiast 40px, etc. Maciek zaleca jednak, by nie definiować tej własności
					w znaczniku w elemencie html i zostawić to przeglądarce. Każdy ma bowiem swoje preferencje, na tych
					customowych ustawieniach przeglądarkowych mogą operować np. osoby niedowidzące, i obecnie w świecie
					designu i frontendu operuje się właśnie względem tych domyślnych 16px. Kiedyś funkcjonowała
					praktyka, że root elemencie definiowano font-size jako 10px (lub 62.5%, co miało ten sam skutek), by
					łatwiej było przeliczać, ale z podanych wcześniej względów, Maciek to odradza. Jeśłi już bardzo
					musimy, to można ustawić jawnie font-size dla elementu html jako 16px, ale Maciek zaleca, by jednak
					pozostawić to domyślnym ustawieniom przeglądarki. Remy można również stosować do nagłówków czy
					marginesów. Jednostka ta stała się obecnie dość popularna.
				</p>
				<img class="image" src="/rem-definition.jpg" alt="Definicja jednostki rem." />
				<p class="article__paragraph">
					Na stronie <a class="article__link" href="https://nekocalc.com/px-to-rem-converter">px to rem converter</a>
					znajduje się kalkulator, gdzie możemy przeliczać remy na piksele i odwrotnie.
				</p>
			</article>
			<article class="article">
				<h3 class="article__header">Flexbox - tryb działania i zawijanie</h3>
				<p class="article__paragraph">
					Flex jest kolejną wartością własności display i stanowi odpowiedź na problemy z wyśrodkowywaniem
					elementów i treści. Jest to jedna z napowszechniejszych obecnie technik stylowania i ustawiania elementów na stronie. Nie jest to zwykła wartość, która decyduje o tym, jak element będzie się
					wyświetlał, ale algorytm, tryb działania własności display, który będzie przeliczał umiejscowienie
					naszych elementów, żeby wyświetlały się w oczekiwany sposób. Display: flex dodany na poziomie
					kontenera sprawia, że 5 elementów, znajdujących się w ramach tego kontenera, które wcześniej
					rozciągały się na całą szerokość wiersza i zajmowały w sumie 5 wierszy, spadają do jednego wiersza i
					każdy z elementów zajmuje tyle miejsca, ile ma treści.
				</p>
				<img class="image" src="/display-flex.jpg" alt="Przykład użycia własności display: flex." />
				<p class="article__paragraph">
					Flex działa tylko w jednym wymiarze i może przyjmować jeden z dwóch głównych trybów działania - w
					poziomie, czyli w osi X (row) i w pionie, czyli w osi Y (column). W przypadku flexa możemy działać
					tylko w tych dwóch osiach (w odróźnieniu od wartości grid, jaką może przyjmować włąsność display,
					która to wartość działa w dwóch wymiarach).
				</p>
				<img class="image" src="/flex-direction.jpg" alt="Opis trybów działania flexa." />
				<p class="article__paragraph">
					Tryb row jest dla flexa trybem domyślnym i sprawia, że elementy zachowują się tak, jak na
					przykładzie powyżej. Natomiast tryb column powoduje, że elementy układają się kolumnowo, w sposób,
					który przypomina display: block.
				</p>
				<img class="image" src="/flex-direction-column.jpg"
					alt="Przykład użycia wartości flex w trybie column." />
				<p class="article__paragraph">
					Własność flex-direction może przyjmować jeszcze dwie wartości: row-reverse oraz column-reverse.
					Sprawiają one, że elementy mają układ odpowiednio poziomy i pionowy, ale elementy w ramach kontenera
					ułożone są odwrotnie niż ma to miejsce w kodzie HTML. W przypadku osi poziomej idą od prawej do
					lewej według odwróconej kolejności, a w przypadku osi pionowej idą od dołu do góry według odwróconej
					kolejności. Zmienia się jednak tylko kolejność wyświetlania elementów, kolejność elementów w DOM
					pozostaje taka, jak w kodzie HTML. W przypadku zwykłego wyśietlania blokowego odwrócenie kolejności
					elementów byłoby niemożliwe bez zmian w drzewie DOM i układzie elementów w kodzie HTML.
				</p>
				<img class="image" src="/row-reverse.jpg" alt="Przykład użycia wartości row-reverse." /><br>
				<img class="image" src="/column-reverse.jpg" alt="Przykład użycia wartości column-reverse." />
				<p class="article__paragraph">
					Kolejną własnością w ramach flexa jest flex-wrap, który odpowiada za zawijanie odpowiednio wiersza
					lub kolumny, zależnie od tego, w której osi pracujemy, i może przyjmować wartości:
				</p>
				<ul class="unordered-list">
					<li class="unordered-list__element">nowrap - brak zawijania, wartość domyślna dla własności
						flex-wrap</li>
					<li class="unordered-list__element">wrap</li>
					<li class="unordered-list__element">wrap-reverse</li>
				</ul>
				<p class="article__paragraph">
					Flex domyślnie stara się upchnąć nasze elementy w jednym wymiarze w określonym pudełku. Jeśli na
					przykładzie naszego kontenera z 5 elementami, nadamy tym elementom szerokość 1000px, to flex
					zmniejszy ich szerokość tak, by zmieściły się w dostępnym oknie przeglądarki, jesli szerokość
					kontenera nie jest zdefiniowana. Jeśli natomaist szerokość kontenera/pudełka zostanie określona jako
					50% dostępnego okna przeglądarki, to elementy również zostaną odpowiednio zmniejszone, by się w tej
					przestrzeni zmieścić, w szerokości całego flexa/kontenera, pomimo tego, że nadal każdy z elementów
					ma szerokość zdefiniowaną na 1000px. Flex jest bowiem algorytmem, funkcją, która przyjmuje różne
					wartości, ale niekoniecznie je bezpośrednio wyświetla. Szerokość pojedynczego elementu na poziomie
					1000px bęzie tu miała charakter umowny, będzie parametrem wejściowym przed wyliczeniem i
					umiejscowieniem poszczególnych elementów przez algorytm flexowy.
				</p>
				<img class="image" src="/flex-nowrap.jpg"
					alt="Przykład użycia własności flex-wrap o wartości nowrap." />
				<p class="article__paragraph">
					Na poniższym przykładzie każdy z 5 elementów znajdujących się w kontenerze flexowym ma szerokość
					zdefiniowaną na 300px. Przy braku zawijania, zostałyby one upchnięte w ramach jednego wiersza,
					jednak z uwagi na to, że na poziomie kontenera została zdefiniowana własność flex-wrap: wrap,
					elementy zawijają się i są przerzucane do następnego wiersza w sytuacji, gdy szerokość dostępna w
					ramach danego wiersza jest niewystarczająca. Flex nie stara się ich upychać w jednym wierszu,
					ponieważ ma informację, żeby zawijać. Każda z 3 osi poziomych na poniższym przykładzie staje się
					takim minikontenerem i będzie przyjmować wartości, które będziemy nadawać temu kontenerowi
					flexowemu. Czyli w wyniku zawijania nie powstają tu 2 wymiary, a nadal jest jeden, poziomy, połamany
					na 3 wiersze.
				</p>
				<img class="image" src="/row-wrap-example1.jpg"
					alt="Przykład użycia własności flex-wrap o wartości wrap w osi poziomej przy braku definicji wysokości elementu." />
				<p class="article__paragraph">
					Jeśli działając w osi poziomej, zdefiniujemy sobie również wysokość elementów i ograniczymy wysokość
					kontenera, to przy zawijaniu zostaną one przeniesione do kolejnych wierszy, zgodnie ze
					zdefiniowanymi parametrami. Flex nie będzie się starał ich upchnąć w ramach dostępnej wysokości
					kontenera, ta wysokość go bowiem nie interesuje. Gdy działa w osi poziomej i operuje na wierszach,
					to interesuje go tylko oś X i tylko w odniesieniu do niej skaluje elementy.
				</p>
				<img class="image" src="/row-wrap-example2.jpg"
					alt="Przykład użycia własności flex-wrap o wartości wrap w osi poziomej przy zdefiniowanej wysokości elementu." />
				<p class="article__paragraph">
					Jeśli w ramach podanego przykładu zmienilibyśmy sobie oś na pionową, nie ograniczając wysokości
					kontenera, to powstałaby jedna kolumna składająca się z 5 elementów i nie byłoby żadnego zawijania,
					ponieważ szerokość elementów na poziomie 300px nie przekracza dostępnej szerokości kolumny. Co do
					zasady w projektach nie chcemy bowiem ograniczać wysokości, treść może wystawać poza okno
					przeglądarki, bo standardem w stronach internetowym jest przewijanie treści w dół, by dostać się do
					całości. Jeśli jednak chcielibyśmy wywołać wrap w osi pionowej, to nie wystarczy dodanie wysokości
					elementów, ale również należy ograniczyć wysokość pudełka, w którym elementy te się znajdują. Jeśli
					zatem zdefiniujemy sobie wysokość elementów na poziomie 200px, ich szerokość na poziomie 300px, a
					wysokość kontenera na poziomie 500px, to elementy, które nie zmieszczą się w ramach jednej kolumny
					500px, zostaną zawinięte i przeniesione do kolejnych kolumn. Flexa nie będzie tu interesować, że
					ostatni, piąty element się nie mieści i wystaje poza szerokość kontenera. Działa on w jednym
					wymiarze, a zatem jeśli pracujemy w osi pionowej i utniemy jej wysokość, to flex działając w ramach
					powstałych ograniczeń, będzie tworzył dodatkowe kolumny rozszerzając treść w bok, poza szerokość
					kontenera ograniczonego szerokością okna przeglądarki. Szerokości w poziomie flex nie potrafi tu
					ogarnąć, upychając elementy, bo jego głównym wymiarem jest w tym przypadku oś pionowa.
				</p>
				<img class="image" src="/column-wrap-example1.jpg"
					alt="Przykład użycia własności flex-wrap o wartości wrap w osi pionowej przy zdefiniowanej szerokości elementu." />
				<p class="article__paragraph">
					Jeśli w ramach podanego przykładu usunęlibyśmy szerokość zdefiniowaną dla elementów, pozostawiając
					ich wysokość na poziomie 200px oraz wysokość całego kontenera na poziomie 500px, to zostaną one
					zawinięte i upchnięte w ramach szerokości okna przeglądarki.
				</p>
				<img class="image" src="/column-wrap-example2.jpg"
					alt="Przykład użycia własności flex-wrap o wartości wrap w osi pionowej przy braku definicji szerokości elementu." />
				<p class="article__paragraph">
					Możemy również zawijać elementy w tył, korzystając z parametru wrap-reverse. Wówczas, w przypadku
					orientacji poziomej, elementy zaczną się u dołu kontenera i będą zawijać w górę, a w przypadku
					orientacji pionowej, początek będzie po prawej stronie okna przeglądarki i elementy będą zawijać się
					w lewą stronę okna. Odwracanie odbywa się na poziomie całych wierszy lub odpowiednio kolumn, a nie
					na poziomie samych elementów.
				</p>
				<img class="image" src="/row-wrap-reverse.jpg"
					alt="Przykład użycia własności flex-wrap o wartości wrap-reverse w przypadku orientacji poziomej." /><br>
				<img class="image" src="/column-wrap-reverse.jpg"
					alt="Przykład użycia własności flex-wrap o wartości wrap-reverse w przypadku orientacji pionowej." />
				<p class="article__paragraph">
					Opisane powyżej własności flex-direction oraz flex -wrap można podawać również w zapisie skróconym
					jako flex-flow, gdzie pierwsza wartość dla włąsności flex-flow odpowiada własności flex-direction, a
					druga to flex-wrap.
				</p>
				<img class="image" src="/flex-flow.jpg"
					alt="Zapis własności flex-direction oraz flex-wrap za pomocą własności flex-flow." />
			</article>
			<article class="article">
				<h3 class="article__header">Flexbox - justify i align</h3>
				<p class="article__paragraph">
					Własność justify-content pozwala na ustawienie elementów wzdłuż osi flex-direction. Własność
					umieszcza się we flexowym kontenerze, by ostylować i rozmieścić znajdujące się w tym kontenerze
					elementy. Same elementy nie muszą wiedzieć, że znajdują się we flexowym kontenerze, będą stylowane
					zgodnie z algorytmem zdefiniowanym w elemencie nadrzędnym. Poniżej znajduje się lista wartości,
					jakie może przyjmować własność justify-content.
				</p>
				<img class="image" src="/justify-content.jpg"
					alt="Wartości, jakie może przyjmować własność justify-content." />
				<dl class="description-list">
					<dt class="description-list__term">justify-content: flex-start</dt>
					<dd class="description-list__details">
						Jest to wartość domyślna. Elementy zostają umieszczone na początku kontenera, czyli po lewej
						stronie w przypadku osi poziomej oraz od góry w przypadku osi pionowej.
					</dd>
					<dt class="description-list__term">justify-content: flex-end</dt>
					<dd class="description-list__details">
						Elementy zostają umieszczone na końcu kontenera, czyli po prawej stronie w przypadku osi
						poziomej oraz od dołu w przypadku osi pionowej. Elementy zostają uszeregowane według
						standardowej kolejności z HTML, ich kolejność nie jest odwracana, tak jak dzieje się to przy
						wartości row-reverse czy column-reverse dla własności flex-direction.
					</dd>
					<dt class="description-list__term">justify-content: center</dt>
					<dd class="description-list__details">
						Powoduje wyśrodkowanie elementów w kontenerze, odpowiednio w osi X lub Y, zależnie od
						zdefiniowanego flex-direction.
					</dd>
				</dl>
				<dl class="description-list">
					<dt class="description-list__term">justify-content: space-between</dt>
					<dd class="description-list__details">
						Elementy zostają ułożone w kontenerze w osi pionowej lub poziomej w taki sposób, że zostaje
						proporcjonalnie zagospodarowana wolna przestrzeń z kontenera, która była dostępna i widoczna np.
						na końcu kontenera przy układzie elementów według wartości justify-content: flex-start. Elementy
						zostają ułożone w taki sposób, że elementy skrajne zostają dosunięte do krawędzi kontenera, a
						wolna przestrzeń jest równo rozdzielona pomiędzy elementy. Elementy są od siebie oddalone o taką
						sama odległość. W momencie powiększania lub pomniejszania okna przeglądarki, odstępy pomiędzy
						elementami są proporcjonalnie powiększane lub pomniejszane.
					</dd>
				</dl>
				<img class="image" src="/space-between.jpg"
					alt="Przykład użycia własności justify-content o wartości space-between w przypadku pionowej orientacji elementów." />
				<p class="article__paragraph">
					W przypadku, gdy mamy zdefiniowaną własność justify-content: space-between dla treści zorientowanej poziomo i zawijanej do kolejnego wiersza (własność flex-wrap: wrap), w taki sposób, że wjednym wierszu znajdują się 3 elementy, a w drugim dwa alementy, to tworząc odstępy między tymi elementami, flex działa w ramach każdego z wierszy osobno. Stają się one jakby osobnymi kontenerami, w ramach których elementy są układane, zgodnie z przyjętymi parametrami. W związku z tym, w pierwszym wierszu odgległość między elementami będzie mniejsza niż w wierszu drugim, ponieważ dostępna wolna przestrzeń do zagospodarowania jest mniejsza w przypadku wiersza pierwszego.
				</p>
				<img class="image" src="/wrap-space-between.jpg"
						alt="Przykład użycia własności justify-content o wartości space-between w przypadku poziomej orientacji elementów oraz użycia włąsności flex-wrap o wartości wrap." />
				<dl class="description-list">
					<dt class="description-list__term">justify-content: space-around</dt>
					<dd class="description-list__details">
						Wartość space-around różni się od space between tym, że dodaje przy krawędziach kontenera
						dodatkowe przestrzenie. Elementy nie są zatem dosunięte do krawędzi kontenera, ale oddalone od
						nich o połowę odległości, jaka jest zachowana między elementami. Wolna przestrzeń w kontenerze
						zostaje bowiem rozdzielona tak, że pomiędzy elementami są równe odległości, a pomiędzy
						elementami a krawędziami kontenera jest odległość równa połowie tej odległości, która istnieje
						między elementami. Na przykładzie poniżej jest to piąta przerwa, która zostaje podzielona na pół
						i dodana na początku i na końcu kontenera.
					</dd>
				</dl>
				<img class="image" src="/space-around.jpg"
					alt="Przykład użycia własności justify-content o wartości space-around w przypadku poziomej orientacji elementów." />
				<p class="article__paragraph">
					Flex działa w jednym wymiarze, ale istnieje możliwość ustawienia elementów wzdłuż drugiej osi. Służy
					do tego własność align-content. Align-content ustawia zatem odpowiednio, całe wiersze lub kolumny, wzdłuż
					osi przeciwnej do flex-direction. Jest to taki justify-content dla drugiej osi.<br>
					Własność align-content działa tylko w przypadku, gdy mamy do czynienia z zawijaniem treści i używamy własności flex-wrap. Czyli tylko wówczas, gdy mamy do czynienia, zależnie od orientacji, z więcej niż jednym wierszem lub więcej niż jedną kolumną.
				</p>
				<img class="image" src="/align-content.jpg"
					alt="Wartości, jakie może przyjmować własność align-content." />
				<p class="article__paragraph">
					Domyślną wartością dla własności align-content jest stretch. Sprawia on, że elementy zawierają w drugiej osi całe dostępne miejsce. Czyli jeśli mamy orientację poziomą i wysokość kontenera 300px, to elementy zostaną tak rozciągnięte w osi pionowej, że zajmą całą dostępną wysokość w ramach tej kolumny. Przy braku definicji wysokości kontenera, na podanym przykładzie elementy byłyby dużo niższe.
				</p>	
				<img class="image" src="/align-content-stretch.jpg"
				alt="Przykład użycia własności align-content o wartości stretch w przypadku poziomej orientacji elementów." />		
				<p class="article__paragraph">
					W przypadku własności align-content o wartości odpowiednio flex-start, flex-end oraz center, wiersze zostaną dosunięte do góry kontenera, do dołu kontenera lub zostaną umieszczone pośrodku kontenera. Flex nie będzie zagospodarowywał dostępnej przestrzeni w ramach kontenera. Przy braku bezpośredniej definicji, elementy będą miały taką wysokość, jaka jest potrzebna do wyświetlenia ich treści, nie będzie ich wysokość dostosowywana do wysokości kontenera.
				</p>
				<img class="image" src="/align-content-flex-end.jpg"	
				alt="Przykład użycia własności align-content o wartości flex-end w przypadku poziomej orientacji elementów." />		
				<p class="article__paragraph">
					W przypadku własności align-content o wartości space-between, elementy zostaną maksymalnie rozsunięte po krawędziach rodzica.
				</p>
				<img class="image" src="/align-content-space-between.jpg"	
				alt="Przykład użycia własności align-content o wartości space-between w przypadku poziomej orientacji elementów." />
				<p class="article__paragraph">
					W przypadku własności align-content o wartości space-around, przestrzeń między elementami zostanie podzielona na 3 podprzestrzenie, przy czym zostanie ona podzielona na dwa i jedna jej część zostanie umieszczona pośrodku, między elemntami. Druga część zostanie natomiast podzielona na pół i połowa będzie oddzielała elementy od górnej krawędzi rodzica, a druga połowa od dolnej krawędzi kontenera.
				</p>
				<img class="image" src="/align-content-space-around.jpg"	
				alt="Przykład użycia własności align-content o wartości space-around w przypadku poziomej orientacji elementów." />	
				<p class="article__paragraph">
					Analogiczną własnością do align-content, ale działającą na poziomie odpowiednio, danego wiersza lub kolumny, a nie całej osi pionowej lub poziomej, jest własność align-items. Odnosi się ona do ustawiania elementów wewnątrz naszego wiersza lub kolumny, wzdłuż osi przeciwnej do flex-direction.
				</p>
				<img class="image" src="/align-items.jpg"
					alt="Wartości, jakie może przyjmować własność align-items." />
				<p class="article__paragraph">
					Domyślna wartość dla własności align-items to stretch. W jej wyniku elementy zostaną rozciągnięte do całej dostępnej szerokości/wysokości kolumny/wiersza z osi przeciwnej do orientacji flex-direction. Jeśli kontener nie miałby podanej wysokości, to element zostanie rozciągnięty do wysokości samego elementu, czyli tyle, ile wymaga tego jego zawartość. Jeśli któryś z elementów w wierszu miałby większą wysokość z uwagi na jego większą zawartość, to wszystkie elementy zostałyby rozciągnięte do wysokości tego najwyższego elementu.
				</p>
				<img class="image" src="/align-items-stretch.jpg"	
				alt="Przykład użycia własności align-items o wartości stretch w przypadku poziomej orientacji elementów." />
				<p class="article__paragraph">
					W przypadku własności align-items o wartości odpowiednio flex-start, flex-end oraz center, elementy zostaną rozmieszczone odpowiednio: u góry, na dole lub w środku osi przeciwnej do orientacji flex-direction. Operując w osi poziomej, elementy zostaną umieszczone odpowiednio: przy górnej krawędzi wiersza, przy dolnej krawędzi wiersza lub pośrodku wiersza.
				</p>	
				<img class="image" src="/align-items-flex-end.jpg"	
				alt="Przykład użycia własności align-items o wartości flex-end w przypadku poziomej orientacji elementów." />
				<p class="article__paragraph">
					W przypadku własności align-items o wartości baseline, elementy są ustawiane względem osi w ten sposób, by zaczynały się na tym samym poziomie, przy czym początek, linia bazowa, wyznaczana jest przez tekst znajdujący się w pierwszym elemencie.
				</p>
				<img class="image" src="/align-items-baseline.jpg"	
				alt="Przykład użycia własności align-items o wartości baseline w przypadku poziomej orientacji elementów." />
				<p class="article__paragraph">
					Istnieje jeszcze coś takiego jak align-self, czyli własność, która pozwala na ustawienie pojedynczego elementu wzdłuż osi przeciwnej do flex-direction. Można zatem ustalić, ze jakiś pojedynczy element będzie zachowywał się inaczej niż pozostałe elementy znajdujące się razem z nim w wierszu.
				</p>
				<img class="image" src="/align-self.jpg"
				alt="Wartości, jakie może przyjmować własność align-self." />
				<p class="article__paragraph">
					Na poniższym przykładzie uzycia flex-direction w osi pionowej, element 2 został ostylowany za pomocą osobnej klasy i własności align-self: center, podczas gdy pozostałe elementy w kolumnie są ostylowane za pomocą własności align-items: stretch.
				</p>
				<img class="image" src="/flex-item-self.jpg"
				alt="Przykład użycia własności align-self o wartości center w przypadku pionowej orientacji elementów w sytuacji, gdy pozostałe elementy w kolumnie są ostylowane za pomocą własności align-items: stretch." />
				<p class="article__paragraph">
					W praktyce naczęściej wykorzystuje się własności justify-content oraz align-items, ponieważ flexa stosuje się zwykle do jednego wiersza. Raczej nie wykorzystuje się go do budowania bardziej skomplikowanych rzeczy, stąd własność align-content w powiązaniu z zawiajniem elementów jest rzadko stosowana.
				</p>
			</article>
			<article class="article">
				<h3 class="article__header">Flexbox - order, basis i devtools</h3>
				<p class="article__paragraph">
					Własność order odpowiada za kolejność elementów i domyślnie przyjmuje wartość 0, ale może przyjmować również inne wartości z zakresu liczb całkowitych, zarówno dodatnie, jak i ujemne. Kolejność ustawiona za pomocą stylów i własności order nie wpływa na kolejność elementów w DOM, a jedynie na kolejność, w jakiej są wyświetlane na stronie. Order działa tylko w ramach danego kontenera flexowego, odnosi się do dzieci danego flexa. Jeśli mamy kilka flexów na stronie, to one się ze sobą nie łączą. Własność order definiuje się dla każdego z nich osobno.
				</p>
				<img class="image" src="/flex-order.jpg"
				alt="Wartości, jakie może przyjmować własność order." />
				<p class="article__paragraph">
					Przestawiając elementy według kolejności z order, im wyższa wartość, tym element będzie się znajdował wyżej w ramach układu warstwowego strony. Przy domyślnym układzie elementów, czyli przy justify-content: flex-start oraz align-items: stretch, alement 3 otrzymał wartość ujemną, podczas, gdy pozostałe elementy mają domyślną wartość order, czyli 0. W efekcie element 3 wylądował na spodzie, czyli na początku wiersza.
				</p>
				<img class="image" src="/flex-item-order.jpg"
				alt="Przykład użycia własności order dla pojedynczego elementu w ramach poziomej orientacji elementów w kontenerze flexowym." />
				<p class="article__paragraph">
					Własność flex-grow również odnosi się do danego kontenera flexowego i domyślnie przyjmuje wartość 0. Można jej nadać równieź inną wartość w postaci innej liczby całkowitej, tzw. proporcji. 
				</p>
				<img class="image" src="/flex-grow.jpg"
				alt="Wartości, jakie może przyjmować własność flex-grow." />
				<p class="article__paragraph">
					Jeśli nadamy elementom, znajdującym się w ramach danego kontenera flexowego, wartość 1, to wolna przestrzeń dostępna w tym kontenerze zostanie podzielona między te elementy według proporcji 1, czyli każdy z elementów otrzyma dodatkowo, poza przestrzenią, którą aktualnie zajmuje, taki sam kawałek dodatkowej przestrzeni. Na naszym przykładzie, gdzie mamy pięć elementów, wolna przestrzeń zostanie podzielona na 5 i każdy z elementów dostanie 1/5 tej przestrzeni.
				</p>
				<img class="image" src="/flex-grow-example1.jpg"
				alt="Przykład użycia własności flex-grow o wartości 1 dla wszystkich elementów w kontenerze flexowym w orientacji poziomej." />
				<p class="article__paragraph">
					Jeśli jednemu z pięciu elementów znajdujących się w kontenerze flexowym, nadamy wartość flex-grow: 2, podczas gdy pozostałe elementy z kontenera mają wartość flex-grow: 1, to wolna przestrzeń w ramach kontenera zostanie podzielona na 6 części, i ten pojedynczy element (na poniższym przykładzie jest to element 4) otrzyma 2/6 (1/3) wolnej przestrzeni, natomiast pozostałe elementy otrzymają po 1/6 z tej przestrzeni.
				</p>
				<img class="image" src="/flex-grow-example2.jpg"
				alt="Przykład użycia własności flex-grow o wartości 2 dla pojedynczego elementu w kontenerze flexowym w orientacji poziomej, podczas gdy pozostałe elementy z kontenera mają wartość flex-grow: 1." />
				<p class="article__paragraph">
					Za pomocą własności flex-grow możemy zatem określać proporcje elementów w ramach kontenera, ale tylko do pewnego momentu, ponieważ elementy nie mogą być mniejsze niż to, co oferuje nam cała wolna przestrzeń. Za pomocą flex-grow możemy jednak nadawać priorytety. Najpopularniejsza wartość dla flex-grow w projektach, to 1, ale można oczywiście ustawiać elementom inne proporcje i priorytety w ramach rodzica flexowego. Proporcje są tutaj liczone za pomocą algorytmu flexowego, przy uwzględnieniu zarówno zdefiniowanych przez nas wartości, jak i ilości elementów oraz dostępnej przestrzeni w kontenerze.
				</p>
				<p class="article__paragraph">
					Jeśli w stosunku do jednego z elementów w ramach kontenera flexowego użyjemy wartości flex-grow: 0, a pozostałe elementy z kontenera będą miały wartość flex-grow: 1, to na naszym przykładzie pięciu emementów, dostępna wolna przestrzeń z kontenera zostanie rozdzielona równo pomiędzy 4 z tych elementów, a element ostylowany za pomocą flex-grow: 0, w ogóle nie będzie rosnął. Nie dostanie żadnej dodatkowej przestrzeni.
				</p>
				<img class="image" src="/flex-grow-example3.jpg"
				alt="Przykład użycia własności flex-grow o wartości 0 dla pojedynczego elementu w kontenerze flexowym w orientacji poziomej, podczas gdy pozostałe elementy z kontenera mają wartość flex-grow: 1." />
				<p class="article__paragraph">
					Własność flex-shrink definiuje, w jaki sposób będzie zachowywał się dany element w sytuacji, gdy ma się kurczyć. Własność ta również odnosi się do danego kontenera flexowego i domyślnie przyjmuje wartość 1. Można jej nadać również inną wartość w postaci innej liczby całkowitej, tzw. proporcji.
				</p>
				<img class="image" src="/flex-shrink.jpg"
				alt="Wartości, jakie może przyjmować własność flex-shrink." />
				<p class="article__paragraph">
					Domyślna własność 1 dla własności flex-shrink oznacza, że mogą się one kurczyć w sytuacji, gdy zmniejszamy dostępny ekran. Jeśli ustawimy sobie wartość flex-shrink: 0, to elementy nie będą się kurczyć, będą miały minimalnie taką szerokość, jaka została dla nich zdefiniowana, czyli w przypadku zmniejszenia ekranu będą wystawać poza dostępne okno przeglądarki.
				</p>
				<img class="image" src="/flex-shrink-example1.jpg"
				alt="Przykład użycia własności flex-shrink o wartości 0 dla elementów o określonej szerokości w kontenerze flexowym w orientacji poziomej, przy zmniejszonej wielkości okna przeglądarki." />
				<p class="article__paragraph">
					W przypadku flex-shrink działanie jest odwrotne w stosunku do tego, jak zachowują się elementy w przypadku własności flex-grow. Dla flex-grow im większa liczba, tym element jest większy, natomaist w przypadku flex shrink im większa liczba, tym element może się bardziej zmniejszyć, czyli dany element będzie dostawał mniej miejsca niż pozostałe. Na poniższym przykładzie jeden z elementów ma wartość flex-shrink: 1, natomiast pozostałe elementy w kontenerze mają wartość flex-shrink: 2. W efekecie, przy zmniejszaniu dostępnego okna przeglądarki, elementy o wartości flex-shrink będą się bardziej zmniejszać niż ten, dla którego zdefiniowano wartość flex-shrink: 1. 
				</p>
				<img class="image" src="/flex-shrink-example2.jpg"
				alt="Przykład użycia własności flex-shrink o wartości 2 dla jednego elementu, podczas gdy pozostałe elementy w kontenerze flexowym mają wartość flex-shrink: 1." />
				<p class="article__paragraph">
					Własność flex-shrink jest najczęściej używana z wartościami 0 i 1, czyli w trybie włącz i wyłącz zmniejszanie elementu.
				</p>
				<p class="article__paragraph">
					Własność flex-basis odnosi się tylko do dzieci naszego flexowego kontenera i domyślnie przyjmuje wartość none, natomiast wartość, którą możemy dla niej ustawić, to tzw. rozmiar bazowy. Flex-basis nie ma zastosowania do elementów, które nie są bezpośrednimi dziećmi naszego kontenera flexowego.
				</p>
				<img class="image" src="/flex-basis.jpg"
				alt="Wartości, jakie może przyjmować własność flex-basis." />
				<p class="article__paragraph">
					Własność flex-basis, zależnie od orientacji naszego kontenera flexowego, odnosi się do szerokości lub wysokości elementu. Pełni funkcję podobną do min-height i min-width. Różnica polega na tym, że jeśli zdefiniujemy sobie dla elementów znajdujących się w kontenerze flexowym własność flex-basis: 100px, to jeśli będziemy mieć orientację poziomą dla tego kontenera, wówczas wartość 100 px będzie odnosiła się do szerokości elementów w tym kontenerze. Jeśłi natomiast zmienimy orientację kontenera na pionową, to wówczas ta sama wartość flex-basis: 100 px, będzie odnosiła się do wysokości elementów w ramach kontenera.
				</p>
				<img class="image" src="/flex-basis-example1.jpg"
				alt="Przykład użycia własności flex-basis dla elementów znajdujących sie w kontenerze flexowym o orientacji pionowej." />
				<p class="article__paragraph">
					Omówione wyżej własności odnoszące się do dzieci flexowych, czyli flex-grow, flex-shrink oraz flex-basis możemy również zapisać skrótowo podając własność flex, która odnosi sie właśnie do dzieci flexowych w ramach kontenera, i wypisująć parametry dla tych własności według podanej kolejności.
				</p>
				<img class="image" src="/flex-properties.jpg"
				alt="Skrótowy zapis własności flex-grow, flex-shrink oraz flex-basis." />
				<p class="article__paragraph">
					Poniżej podany jest przykład skrótowego zapisu parametrów flex dla elementów znajdujących się w kontenerze o orientacji pionowej. Poszczególne własności, które zostały zdefiniowane w skrótowym zapisie można oczywiście nadpisać i zdefiniować inaczej dla wybranych elementów.
				</p>
				<img class="image" src="/flex-properties-example.jpg"
				alt="Przykład skrótowego zapisu parametrów flexowych opisującyh dzieci w ramach kontenera flexowego." />
				<p class="article__paragraph">
					Odstępy między elementami możemy definiować za pomocą tzw. gapów. Zaczniemy od własności row-gap, który jak nazwa wskazuje, odnosi się do odstępów między wierszami. W związku z tym, że zwykle operuje się na jednym wierszu lub kolumnie, to użycie tej własnoći najlepiej będzie widać na przykładzie elementów znajdujących sie w kontenerze flexowym o orientacji pionowej.
				</p>
				<img class="image" src="/row-gap.jpg"
				alt="Wartości, jakie może przyjmować własność row-gap." />
				<p class="article__paragraph">
					Analogicznie, użycie własności column-gap najlepiej będzie widać na przykładzie elementów znajdujących sie w kontenerze flexowym o orientacji pionowej. Na poniższym przykładzie odstępy między kolumnami zostały zdefiniowane jako 2 remy (32 piksele). Maciek zaleca stosowanie zapisu tej własności po prostu jako gap, na tym przykładzie byłoby to gap: 2rem. Wóczas nie zależnie od tego, czy będziemy znajdować się w orientacji poziomej czy pionowej, odległość między tymi elementami będzie zawsze zdefiniowana jako gap.
				</p>
				<img class="image" src="/column-gap-example.jpg"
				alt="Przykład użycia własności column-gap dla elementów znajdujących sie w kontenerze flexowym o orientacji poziomej." />
				<p class="article__paragraph">
					Aby dobrze zobrazować sobie działanie flexa, można korzystać z narzędzi developerskich w przeglądarce, gdzie w zakładce Elements, jest widoczne użycie flexa dla danych elementów.
				</p>
				<img class="image" src="/devtools-flex.jpg"
				alt="Widok użycia flexa w zakładce Elements w devtools." />
				<p class="article__paragraph">
					Najbardziej użyteczna jest jednak ikonka, która pojawia się przy własności display: flex zdefiniowanej dla naszego elementu. Po kliknięciu w nią, pojawia się panel, który podświetla aktualnie użyte własności i pozwala na łatwy wybór innych własności, by przetestować sobie ich użycie na naszych elementach. Efekty są od razu widoczne, bez konieczności wprowadzania zmian w kodzie. Jest to bardzo wygodna opcja, by zrozumieć, jak działa flexbox.
				</p>
				<img class="image" src="/devtools-flex-icon.jpg"
				alt="Panel w devtools do testowania własności flexowych." />
				<p class="article__paragraph">
					W devtools można również w podobny sposób przetestować sobie wartości dla samego flexa, gdyż po dodaniu danej własności, narzędzie podpowiada nam dostępne dla niej wartości, przez które można się przeklikać, podglądając na bieżąco efekty, ale nie jest to już tak instuicyjne, jak panel dla flexboxa.
				</p>
				<img class="image" src="/devtools-flex-options.jpg"
				alt="Podgląd opcji dostępnych dla danych własności flexowych." />
			</article>
			<article class="article">
				<h3 class="article__header">CSS - stylowanie tła</h3>
				<p class="article__paragraph">
					
				</p>
			</article>
		</section>

	</main>
	<footer class="footer">
		<p class="footer__content">Strona domowa Magdaleny Derek, wszystkie treści są wynikiem nauki w ramach szkolenia
			WTF: Co
			ten frontend.
			<a class="footer__top-link" href="#top">Wróć na górę strony ⬆️</a>
		</p>
	</footer>
	<script defer src="/main.js"></script>
</body>

</html>