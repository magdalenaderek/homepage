<!DOCTYPE html>
<html lang="pl">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Notatki z frontendu</title>
	<link href="style.css" rel="stylesheet" type="text/css">
</head>

<body class="body">
	<header class="header">
		<nav>
			<a class="header-link" href="index.html">Strona główna</a>
			<a class="header-link" href="nauka-html.html">Nauka HTML</a>
			<a class="header-link" href="nauka-css.html">Nauka CSS</a>
			<a class="header-link" href="nauka-js.html">Nauka JavaScriptu</a>
			<a class="header-link" href="nauka-varia.html">Nauka - varia</a>
		</nav>

	</header>
	<main class="main">
		<header id="top">
			<h1 class="main-header">Nauka CSS-a</h1>

		</header>
		<section class="section">
			<h2 class="section-header">CSS - tydzień 2</h2>
			<article class="article">
				<h3 class="article-header">CSS - podstawowe informacje i selektory, kolory</h3>
				<p class="paragraph"><b>CSS – Cascading style sheets</b> – odpowiada za prezentację, wygląd treści.
					Każdy język ma swoją składnię, w przypadku CSS są to reguły, mające następującą budowę: <br>
					selektor { <br>
					właściwość: wartość; <br>
					}
				</p>
				<p class="paragraph">Style co do zasady definiuje się w osobnym pliku o rozszerzeniu .css, ale można je
					też zdefiniować w
					pliku html w sekcji "head" poprzez dodanie znacznika "style", gdzie definiujemy właściwości
					poszczególnych elementów, odnosząc się do nich za pomocą selektorów, którymi mogą być nazwy tych
					elementów (np. h1, p), np.: <br>
					p { <br>
					color: green; <br>
					}
				</p>
				<p class="paragraph">Sposobów zapisu kolorów jest kilka, np. angielska nazwa, zapis heksadecymalny,
					czyli w systemie
					szestnastkowym - #xxyyzz, gdzie xx to kanał czerwony, yy to kanał zielony, a zz to kanał niebieski.
					Style określa się jednak najczęściej w zewnętrznym arkuszu stylów, a w samym pliku html zawiera się
					do niego odnośnik poprzez odpowiednia frazę – znacznik "link" o odpowiedniej składni.
					Kolejną własnością, obok koloru, jest tło. Można je określić dla całej strony wskazując jako
					selektor "body", czyli np.: <br>
					body { <br>
					background: lightyellow; <br>
					}
				</p>
				<p class="paragraph">
					Możemy zaprojektować paletę kolorystyczną naszej strony posiłkując się
					<a class="link" href="https://coolors.co">generatorem coolors</a>
				</p>
			</article>
		</section>
		<section class="section">
			<h2 class="section-header">CSS - tydzień 3</h2>
			<article class="article">
				<h3 class="article-header">Stylowanie w oparciu o atrybuty element, id i klasa</h3>
				<p class="paragraph">
					Oprócz tego, że style można zamieścić w ramach znacznika style w sekcji "head" lub w pliku
					zewnętrznym, można je też zastosować używając atrybutu "style" i przypisując go do konkretnego
					znacznika, np. section, h1, p, etc. wg schematu: <br>
					znacznik style="color:yellow; background:#ffffff;" treść /znacznik <br>
					Styl przy znaczniku z wykorzystaniem atrybutu "style" nazywamy stylem inline, liniowym. Znajduje on
					zastosowanie jedynie do tego konkretnego znacznika, przy którym atrybut ten został wpisany. <br>
					Aplikowanie stylów w ten sposób nie ma jednak większego sensu, bo robi się bałagan - kod staje się
					nieczytelny i trudny do modyfikacji. I tutaj właśnie w grę wchodzą tzw. prawdziwe selektory -
					wcześniej stylowaliśmy odnosząc się do elementów, natomiast najlepiej to robić w oparciu o
					identyfikatory i klasy: #id i .class. Zwłaszcza klasy, które dodaje się do znaczników wg schematu:
					<br>
					znacznik class="name" treść /znacznik <br>
					Atrybut .class dodajemy w html przy danych tagach/znacznikach (pozwala na pogrupowanie elementów),
					natomiast przekłada się on na stylowanie i cssy. Nazwę, którą nadajemy danej klasie, tworzymy wg
					schematu kebab-case. Aby ostylować elementy, które mają przypisaną daną klasę, odnosimy się do nich
					w pliku ze stylami w następujący sposób: <br>
					.name { <br>
					właściwość: wartość; <br>
					} <br>
					.(kropka) - to selektor klasy
				</p>
				<p class="paragraph">
					Do stylowania elementów można wykorzystać również id, które wcześniej nadaliśmy tagom po to, by
					wykorzystać je jako kotwicę służącą do przenoszenia się w ramach dokumentu do konkretnej sekcji.
					Identyfikator nadaje się elementom i wykorzystuje do stylowania wg następującego schematu: <br>
					znacznik id="name" treść /znacznik <br>
					#name { <br>
					właściwość: wartość; <br>
					} <br>
					# (hash) - to selektor id <br>
					Na danej stronie dokumentu może znajdować się tylko jedno id o danej konkretnej wartości, przypisane
					do jednego konkretnego elementu.
				</p>
				<p class="paragraph">
					Selektory można łączyć, czyli do danego znacznika może byc przypisane konkretne id i określona
					klasa. <br>
					Jeśli chcemy ostylować wg określonego wzoru wszystkie linki, które znajdują się w obszarze nawigacji
					"nav", tak by stylowanie odróżniało je od pozostałych linków występujących w treści dokumentu.
					Elementy o znaczniku "a" są zatem zagnieżdżone w znaczniku "nav", chcemy więc ostylować elementy
					znajdujące się w innym elemencie. Odnosimy się do nich w pliku z cssami wpisując po sobie elementy
					"nav" i po spacji "a" wg wzoru: <br>
					nav a { <br>
					własność: wartość1; <br>
					} <br>
					a { <br>
					własność: wartość2; <br>
					} <br>
					Przy takim zapisie style nie zaaplikują się do samego znacznika "nav", ale do zawartych w nim
					elementów "a", gdzie dana własnośc będzie miała wartość1. Natomiast pozostałe elementy "a", które
					nie są zagnieżdżone w "nav" przyjmą wartość2 dla tej własności. Odnosząc się do elementów "a"
					zawartych w "nav" nie musimy więc podawać dokładnej ścieżki body>header>nav, wystarczy podanie
					bezpośredniego rodzica, czyli "nav". Nie musi to być również bezpośredni rodzic - w tym przypadku
					ten sam efekt osiągniemy wpisując ścieżkę header>a.
				</p>
			</article>
			<article class="article">
				<h3 class="article-header">!important i specyficzność w CSS</h3>
				<p class="paragraph">
					!important to zmora, jeśli chodzi o stylowanie. Nie powinno się tego używać, ponieważ !important
					dopisany przy wartości dla danej własności opisującej określony element sprawia, że styl, przy
					którym został on dodany nadpisuje wszystkie inne style, które zostały zdefiniowane dla danego
					elementu. Opierając się na wcześniejszym przykładzie rozróżnienia stylów linków zagnieżdżonych w
					znaczniku "nav" oraz linków znajdujących się poza tym znacznikiem w treści dokumentu, dodanie
					"!important" przy własności zdefiniowanej dla linków niezagnieżdżonych sprawia, że wszystkie linki,
					zagnieżdżone i niezagnieżdżone, zostaną ostylowanie zgodnie z tym stylem. Przykład takiego zapisu:
					<br>
					nav a { <br>
					własność: wartość1; <br>
					} <br>
					a { <br>
					własność: wartość2 !important; <br>
					} <br>
					Wstawienie importanta w jakimś miejscu może więc sprawić, że stylowanie całej strony się posypie.
					Zatem jeśli nie musimy i zastosowanie importanta nie jest naprawdę celowe w danym przypadku, to go
					nie używajmy.
				</p>
				<p class="paragraph">
					Co w sytuacji, gdy do danego elementu mamy zdefiniowane stylowanie zarówno w pliku css, jak i przy
					danym znaczniku jako inline, tak jak na poniższym przykładzie? <br>
					W pliku CSS mamy zapis: <br>
					#name { <br>
					color: red; <br>
					} <br>
					Natomiast w kodzie html przy danym elemencie mamy wstawiony inline: <br>
					span id="name" style="color: yellow" treść /span <br>
					Dla treści elementu span o id=name mamy więc zdefiniowany w pliku css kolor czerwony, natomiast w
					stylu liniowym kolor żółty. Przeglądarka zastosuje tutaj styl zdefiniowany w inline, czyli treść
					będzie miała kolor żółty. <br>
					Jest to przykład występowania specyficzności w CSS, czyli zasad ważności sposobów zastosowania
					stylów w sytuacji, gdy są one w konflikcie. Specificity to zatem zasada, która określa który
					selektor ma pierwszeństwo w przypadku, kiedy wiele z nich ustawia te same reguły CSS dla tego samego
					znacznika HTML. Kolejność ta została zwizualizowana na poniższym obrazku.
				</p>
				<img class="image" src="specificity-rules.JPG"
					alt="Obrazek przedstawiający kolejność zastosowania selektorów: important, inline, id, klasa, element." />
				<p class="paragraph">
					Zastosowanie ma zatem następująca kolejność wg pierwszeństwa obowiązywania reguł wprowadzonych przez
					selektory: important, inline, id, klasa, element. Przy czym dwa pierwsze, important i inline, są
					stosowane rzadko, dlatego zostały ujęte w nawiasie. <br>
					Przykładowo, jeśli mamy zdefiniowane dwie reguły css dla znacznika h1 w taki sposób jak poniżej,
					czyli w jednej z nich jako selektor podajemy sam pojedynczy znacznik h1, natomiast w drugiej
					uwzględniamy zagnieżdżenie tego znacznika h1 w elemencie body (jako selektor podajemy dwa elementy -
					dziecko i rodzica), to w opierając się na zasadach specificity, zastosowanie będzie miała reguła CSS
					zdefiniowana w oparciu o selektor z dwoma elementami (bo dwa elementy to więcej niż jeden element).
					<br>
					h1 { <br>
					color: red; <br>
					} <br>
					body h1 { <br>
					color: yellow; <br>
					} <br>
					Nagłówek będzie zatem żółty, ponieważ reguła CSS definiująca ten styl <b>ma wyższą
						specyficzność</b>. Poniżej znajduje się obrazek przedstawiający wizualizację tego
					przykładu.
				</p>
				<img class="image" src="specificity-example1.JPG"
					alt="Obrazek przedstawiający pierwszeństwo zastosowania reguł CSS, gdy jedna jest zdefiniowana w oparciu o selektor jednoelementowy, a druga dwuelementowy." />
				<p class="paragraph">
					To, która z reguł CSS będzie miała zastosowane jest również widoczne w devtools w przeglądarce -
					styl, który został nadpisany jest przekreślony. Przekreślone są również zwykle domyślne style
					przeglądarki, gdy są nadpisywane przez nas. W tym przypadku nie są przekreślone, bo taka własność
					nie została zdefiniowana w przeglądarce (zadziałoby się tak np. w przypadku stylów zdefiniowanych
					dla
					linków). Poniżej zrzut ekranu z devtools dla omawianego przypadku.
				</p>
				<img class="image" src="specificity-example-devtools.jpg"
					alt="Zrzut ekranu z devtools przedstawiający pierwszeństwo zastosowania reguł CSS, gdy jedna jest zdefiniowana w oparciu o selektor jednoelementowy, a druga dwuelementowy." />
				<p class="paragraph">
					Devtools pozwala też na dodanie w zakładce elements do znacznika body atrybutu "contenteditable",
					poprzez
					kliknięcie prawym przyciskiem i wybór opcji add atribute. Po dodaniu atrybutu można na żywo edytować
					stronę z
					poziomu jej widoku, a nie narzędzi w devtools.
				</p>

				<p class="paragraph">
					Kolejnym przykładem zastosowania reguł specyficzności css jest sytuacja, gdy do danego nagłówka
					zostały użyte reguły css, z których jedna styluje go w oparciu o selektor składający się z trzech
					elementów, natomiast druga używa selektora w postaci id. <br>
					html body h1 { <br>
					color: yellow; <br>
					} <br>
					#main-header { <br>
					color: red; <br>
					} <br>
					Wyższą specyficzność będzie miała tu reguła definiująca kolor czerwony. Mimo tego, że kolor żółty
					opiera sie na selektorze składającym się z trzech elementów, a kolor czerwony określany jest dla
					selektora składającego sie z jednego id, to id ma większą wagę i pierwszeństwo w zasadach
					specyficzności. Wizualizację tego przykładu zawiera poniższy obrazek.
				</p>
				<img class="image" src="specificity-example2.JPG"
					alt="Obrazek przedstawiający pierwszeństwo zastosowania reguł CSS, gdy jedna jest zdefiniowana w oparciu o selektor trójelementowy, a druga selektor id." />
				<p class="paragraph">
					Na kolejnym przykładzie mamy sytuację, gdy jeden ze stylów zdefiniowany jest w oparciu o id i trzy
					elementy, natomiast drugi w oparciu o id, klasę i jeden element. Wyższą specyficzność będzie miała
					reguła CSS bazująca na id, klasie i jednym elemencie, ponieważ zawiera więcej selektorów o wyższej
					wadze - id i klasa (2). Można to też przeczytać jako całe liczby i w ten sposób 111 > 103, a zatem
					nagłówek będzie miał kolor czerwony. Poniżej zapis kodu i obrazek, który ilustruje ten przykład.<br>
					(Selektor id piszemy łącznie z selektorem elementu, do którego się odnosi, bez spacji. To samo w
					przypadku selektora klasy, który odnosi się do danego elementu).
					<br>
					html body h1#main-header { <br>
					color: yellow; <br>
					} <br>
					body .section #main-header { <br>
					color: red; <br>
					}
				</p>
				<img class="image" src="specificity-example3.JPG"
					alt="Obrazek przedstawiający pierwszeństwo zastosowania reguł CSS, gdy jedna jest zdefiniowana w oparciu o id i trzy elementy, a druga w oparciu o selektor id, klasę i jeden element." />
				<p class="paragraph">
					<strong>Jeśli specyficzność jest równa, to pierwszeństwo ma selektor znajdujący się "bliżej"
						elementu.</strong> <br>
					Przykładowo w jednym pliku style.css mamy zdefiniowane dwie reguły składające się z tych samych
					selektorów,
					lecz każda z tych reguł styluje dany element w inny sposób. I jedna z reguł znajduje się pod drugą w
					treści pliku, przy czym reguła definiująca kolor czerwony znajduje się wyżej niż reguła stylująca
					kolor niebieski. Zastosowanie będzie miała tu reguła stylująca kolor niebieski, czyli ta, która jest
					niżej, ponieważ znajduje się ona bliżej stylowanego elementu.<br>
					body section#main h1.heading { <br>
					color: red; <br>
					} <br>
					body section#main h1.heading { <br>
					color: blue; <br>
					}
				</p>
				<p class="paragraph">
					Aby unaocznić sobie, na czym polega ta bliskość, wyobrażamy sobie, że style zdefiniowane w pliku
					style.css są umieszczone w pliku HTML w miejscu, gdzie znajduje się odniesienie do pliku css. Na
					przykładzie zobrazowanym poniżej element header ma przypisaną klasę "styl1", w oparciu o którą
					został ostylowany w pliku css, gdzie dla tej samej reguły określono dwa różne style. Zastosowany
					zostanie styl definiujący kolor niebieski, ponieważ jest umieszczony niżej, a tym samym fizycznie
					znajduje się bliżej elementu header.
				</p>
				<img class="image" src="specificity-example4.JPG"
					alt="Zrzut ekranu przedstawiający, na czym polega bliskość stylowanego elementu reguły znajdującej sie niżej w pliku." />
				<p class="paragraph">
					Analogicznie wygląda sytuacja, jeśli wpiszemy w pliku style.css dwa style w jeden selektor, np.:
					<br>
					body section#main h1.heading { <br>
					color: red; <br>
					color: blue; <br>
					} <br>
					Pierwszeństwo będzie miał ten, który jest niżej, czyli w tym przypadku niebieski.
				</p>
				<p class="paragraph">
					<strong>Rekomendowane jest dodawanie klas do wszystkich elementów (nawet jeśli mamy tylko jeden
						element danego typu) i unikanie zagnieżdżeń przy stylowaniu (np. selektorów składających się z
						kilku elementów).</strong>
				</p>
				<p class="paragraph">
					Można przyjąć następujące wytyczne dla tworzenia nazw klas: <br>
					1. Używamy pojedynczych angielskich słów rozpoczynających się od małej litery, a jeśli jest
					konieczne użcie dwóch słów, to stosujemy kebab-case. <br>
					2. Nie zaczynamy od cyfry. <br>
					3. Nazywamy rzeczy zgodnie z ich funkcją na stronie. <br>
					4. Nie zwiększamy specyficzności bez potrzeby - staramy się, by element miał tylko jedną klasę i
					stylujemy po klasach.
				</p>
			</article>
			<article class="article">
				<h3 class="article-header">Dziedziczenie</h3>
				<p class="paragraph">
					Cześć własności, zdefiniowanych dla danego elementu, może być dziedziczona (ale nie wszystkie).
					Dziedziczenie idzie z góry do dołu, od rodzica, do potomków. Jeśli nie mamy jawnie zdefiniowanych
					stylów dla danego elementu, to dziedziczy on style od swojego rodzica, dla którego te style zostały
					zdefiniowane. Przykładowo, jeśli mamy strukturę, w ramach której jest artykuł, a w nim nagłówek h3
					oraz paragraf i ten artykuł ma nadaną klasę, w ramach której został zdefiniowany kolor czcionki, to
					kolor ten zostanie zaimplementowany również do nagłówka h3 oraz paragrafu, dla których bezpośrednio
					żadne style nie zostały zdefiniowane. Jeśli natomiast w podanym przykładzie dla paragrafu zostałaby
					nadana klasa, w ramach której zdefiniowany zostałby kolor czcionki, to nagłówek h3 odziedziczy kolor
					czcionki zdefiniowany dla artykułu, natomiast do paragrafu zostanie zastosowany kolor czcionki,
					który został dla niego zdefiniowany bezpośrednio. Taka sama sytuacja będzie miała miejsce nawet,
					jeśli do stylu zaapliowanego do artykułu dodamy importanta - do paragrafu nadal będzie miał
					zastosowanie kolor czcionki, który zdefiniowany jest dla niego bezpośrednio. Pierwszeństwo ma zawsze
					definicja jawna, bez dziedziczenia.
				</p>
				<p class="paragraph">
					Gdybyśmy mieli strukturę, w ramach której jest artykuł, a w nim nagłówek h3 oraz paragraf, w
					którym znajduje się link, i ten artykuł ma nadaną klasę, w ramach której został zdefiniowany kolor
					czcionki, to kolor ten zostanie zaimplementowany również do nagłówka h3 oraz paragrafu, dla których
					bezpośrednio żadne style nie zostały zdefiniowane. Do linku jednak kolor czcionki zdefiniowany dla
					klasy artykułu nie zostanie zaimplementowany. Mimo, że my dla linków nie mamy zdefiniowanych
					bezpośredniostylów czcionki, to takie definicje ma w sposób jawny utworzone sama przeglądarka i w
					tym przypadku do koloru czcionki linku, który znajduje si e w paragrafie, zostanie zaimplementowany
					domyślny styl z przeglądarki (można te definicje podejrzeć w devtools, badając dany element).
				</p>
				<p>
					Do definicji stylów można zastosować wartość <strong>inherit</strong>. W takim przypadku, mając
					strukturę, w ramach której jest artykuł, a w nim nagłówek h3 oraz paragraf, w którym znajduje się
					link, i ten artykuł ma nadaną klasę, w ramach której został zdefiniowany kolor czcionki, to dodając
					w stylach dla linków kolor czcionki o wartości "inherit", kolor linku zostanie odziedziczony z
					definicji dla artykułu, pomimo tego, że dla linku nie mamy zdefiniowanych kolorów jako takich i
					pomimo jawnej definicji koloru linku z przeglądarki.<br>
					article a {<br>
					color: inherit;<br>
					}<br>
					Jeśli chcemy, by linki zawsze dziedziczyły kolor z elementów powyżej i były w tym samym kolorze, co
					tekst naokoło, to można dodać w stylach definicję odnoszącą się do wszystkich linków:<br>
					a {<br>
					color: inherit;<br>
					}<br>
					W ten sposób pozbywamy się definitywnie domyślnych definicji dla koloru linków z prezglądarki i nie
					musimy tworzyć osobnych definicji dla kolorów linków w różnych miejscach. Możemy sobie je potem
					oczywiście nadpisywać, np. za pomocą klas.
				</p>
				<img class="image" src="inherited-styles.jpg"
					alt="Lista własności, których style mogą być dziedziczone." />
			</article>
		</section>
		<section class="section">
			<h2 class="section-header">CSS - tydzień 4</h2>
			<article class="article">
				<h3 class="article-header">Box model i własności CSS</h3>
				<p class="paragraph">
					Box model to fundamentalny model, z którego korzysta nasza przeglądarka do wyświetlania treści.
					Świat stron internetowych jest co do zasady płaski, dwuwymiarowy. Poruszamy się w przestrzeni x i
					y.</br>
					&lt;div&gt; tzw. pudełko, znacznik, który nie ma żadnego znaczenia semantycznego, służy do
					opakowywania różnych treści w sytuacji, gdy nie istnieje odpowiedni semantyczny znacznik. Znacznik
					ten przydaje się przy stylowaniu, ale jeśli używamy go po prostu do opakowywywania treści, to
					prawdopodobnie robimy to źle.
				</p>
				<p class="paragraph">
				<h4 class="paragraph-header">Display</h4>
				<b>display: block;</b> - powoduje, że element, który ostylujemy, nadając mu własność display o wartości
				block, zajmuje całą szerokość, jaką może zająć, a kolejne elementy będą przerzucane do nowej linii.
				Tworzony jest blok, który zajmuje całą szerokość, a kolejne rzeczy przerzucane są niżej. Jest to
				domyślny styl, jaki przeglądarka nadaje elementom na stronie (również w przypadku treści opakowanej w
				znaczniki &lt;section&gt; czy &lt;article&gt;). Styl display: block; można jednak stosować również do
				innych elementów niż te, które przeglądarka domyślnie ostylowuje w ten sposób, np. do linków, obrazków,
				etc.<br>
				Jeśli do stylowania elementu dodamy również takie własności jak wysokość i szerokość, to w sytuacji, gdy
				dostępna szerokość będzie większa niż zdefiniowana, sam element będzie miał szerkość określoną w
				definicji, ale reszta przestrzeni zostanie zarezerowana również dla tego elementu, a pozostałe elementy
				zrzucone niżej. <br>
				<img class="image" src="display-block.jpg"
					alt="Przykład treści ostylowanej za pomocą własności display: block." />
				<b>display: inline;</b> - każdy z boxów, który ostylujemy w ten sposób, dostosowuje się do tego, co się
				w nim znajduje. Nie zajmuje zatem całej dostępnej szerokości, a tylko taką, jaka potrzebna jest do
				wyświetlenia jego zawartości. Ponadto do elementu ostylowanego w ten sposób nie będą miały zastosowania
				zdefiniowane dla niego wartości height i width, element taki musi być liniowy.<br>
				<img class="image" src="display-inline.jpg"
					alt="Przykład treści ostylowanej za pomocą własności display: inline." />
				<b>display: inline-block;</b> - jest to hybryda wartości inline i block; elementy ostylowane w ten
				sposób, jeśli mają małą zawartość, to zachowują się jak elementy inline. Jeśli natomiast element jest
				szerszy i wychodzi na kolejny wiersz, to rozszerza się i blokuje całą jego szerokość.<br> Jeśli
				natomiast element taki będzie miał zdefiniowaną wysokość i szerokość, to podobnie, jak w przypadku
				wartości block, gdy jest dostępna przestrzeń większa niż zdefiniowana, element będzie miał szerokość
				określoną w definicji, ale pozostała przestrzeń nie będzie już dla niego zarezerwowana, zostanie zajęta
				przez kolejny element.<br>
				<img class="image" src="display-inline-block.jpg"
					alt="Przykład treści ostylowanej za pomocą własności display: inline-block." />
				</p>
				<p class="paragraph">
				<h4 class="paragraph-header">Width i height</h4>
				Jeśli nasz element ma zdefiniowaną wysokość i szerokość i zmniejszymy okno przeglądarki, to sam element
				pozostanie cały czas tej samej szerkości/wysokości, ale w oknie przeglądarki pojawi się scroll, który
				pozwoli na przewinięcie do fragmentów elementu niedostępnych w widoku. Jeśli natomist wartości te nie są
				zdefiniowane, to przy zmniejszaniu/zwiększaniu okna przeglądarki, wielkość elementu zmienia się,
				dostosowując do dostępnego miejsca.<br>
				<b>max-width</b> - Jeśli okno przeglądarki jest szersze niż zdefiniowana wartość dla szerkości elementu,
				to jego szerokość jest dokładnie taka, jak określono w definicji. Jeśli natomiast zmiejszymy okno
				przeglądarki i jej szerokość będzie mniejsza niż maksymalna szerokość zdefiniowana dla elementu, to
				szerokość elementu się zmniejszy i dostosowuje się on do dostępnej przestrzeni. Czyli wraz ze zmianą
				szerokości okna przeglądarki, szerokość elementu może się zmniejszać, ale nie zwiększy się bardziej niż
				wartość określona w max-width.<br>
				<b>max-height</b> - Jeśli określimy max-height i będzie ona większa niż zawartość elementu, który
				stanowi przykładowo jakiś literał, to w oknie przeglądarki element zajmie najmniejszą potrzebną mu
				wysokość - w tym przypadku jeden wiersz. Jeśli natomiast zawartość elementu jest większa niż wartość
				max-height, np. jest to wiele linijek tekstu, to element wyświetli się w maksymalnie określonej
				wysokości, natomiast jego zawartość będzie wykraczać poza przewidzianą dla elementu przestrzeń.<br>
				<img class="image" src="max-height.jpg"
					alt="Przykład treści ostylowanej za pomocą wartości max-height, gdy zawartość elementu jest wyższa i wystaje poza element." />
				</br>
				<b>min-width</b> - Jeśli ustalimy minimalną szerokość większą niż dostępna szerokość okna, to pojawi się
				scroll, który pozwoli na dostanie się do niedostępnej części elementu.<br>
				<b>min-height</b> - Jeśli ustalimy minimalną wysokość dla elementów, to te elementy, których zawartość
				nie przekracza ustalonej wysokości minimalnej będą miały taką wysokość, jak zdefiniowana minimalna.
				Jeśli natomiast zawartość elementu ma większą wysokość niż zdefiniowana minimalna, to element przyjmie
				taką wysokość, jaka jest potrzebna, by zmieścić zawartość.
				</p>
				<p class="paragraph">
				<h4 class="paragraph-header">Overflow</h4>
				Własność overflow definiuje, jak ma zachować się element w sytuacji, gdy treść za niego wystaje.<br>
				<b>overflow: hidden;</b> - ukrywa całą treść, która nie mieści się w elemencie, ucina wszystko, co
				wystaje poza jego zdefiniowaną wysokość i szerokość.<br>
				<b>overflow: auto;</b> - w sytuacji, gdy zawrtość elementu jest wyższa niż element, własność overflow o
				wartości auto dodaje wewnątrz elementu scrolla, który pozwala na dostęp do całej treści zawartej w
				elemencie.<br>
				<img class="image" src="overflow-auto.jpg"
					alt="Przykład treści ostylowanej za pomocą własności overflow: auto." /> <br>
				<b>overflow: clip;</b> - na naszym obecnym przykładzie zachowuje się jak overflow:hidden, ale gdy
				stylujemy nasze strony w bardziej zaawansowany sposób, to wykorzystujemy w sytuacji, gdy pewne elementy
				chcemy tak wypozycjonować, by wykraczały poza nasze body.<br>
				<b>overflow: scroll;</b> - dodawany jest scroll do wszystkich elementów ostylowanych w ten sposób,
				niezależnie od wysokości i szerokości. Nie we wszystkich elementach scroll będzie działać, a jedynie w
				tych, w przypadku których zawartość elementu wykracza poza określoną dla niego wysokość lub szerokość. W
				przypadku overflow: auto, scroll dodawany jest tylko tam, gdzie jest naprawdę potrzebny.<br>
				<img class="image" src="overflow-scroll.jpg"
					alt="Przykład treści ostylowanej za pomocą własności overflow: scroll." /> <br>
				<b>overflow: visible;</b> - powoduje, że treść, która wykracza poza dostępną wysokość lub szerokość
				elementu nie jest ukrywana, ale wystaje za element. Jeśli za elementem, z którego wystaje treść,
				umieścimy kolejny, w którym określona dla niego zawrtość się mieści, to element ten dodawany jest od
				razu za poprzedzającym go elementem. Przestrzeń nie jest rezerowana na niemieszczącą się treść. W takiej
				sytuacji treści obu elementów mogą się na siebie nakładać.<br>
				<img class="image" src="overflow-visible.jpg"
					alt="Przykład treści ostylowanej za pomocą własności overflow: visible." />
				</p>
			</article>
			<article class="article">
				<h3 class="article-header">Jednostki</h3>
				<p class="paragraph">
				<h4 class="paragraph-header">Piksele</h4>
				Wartość 0 możemy zapisywać bez jednostek. Nie ma znaczenia, czy są to piksele, procenty czy jeszcze coś
				innego, zapisujemy po prostu 0.<br>
				Piksele zapisujemy jako px, piksel jest to po prostu punkt na ekranie. Jednostke zapisujemy razem z
				liczbą, bez spacji, np. 200px, w przeciwnym razie to nie zadziała. Piksel jako jednostka nie ma
				przełożenia na gęstość pikselową ekranów. Piksele określające np. rozdzielczość HD składają się na
				większe piksele, które stosowane są jako jednostki. To, że rozdzielczość ekranów zmienia się, składa się
				na nią coraz większa liczba pikseli, poprawiając jakość obrazu, nie wpływa na zmianę wielkości piskeli
				jako jednostek, które wciąż pozostają takie same. Przeglądarka sobie to poprawnie przelicza.
				</p>
				<p class="paragraph">
				<h4 class="paragraph-header">Procenty</h4>
				Procenty zapisujemy jako %, również bez spacji, np. 50%. Wartość ta musi mieć jakiś punkt odniesienia,
				rodzica, w naszym przypadku będzie to po prostu body. Jeśli podamy dla elementu szerokość 50%, to będzie
				on zajmował połowę dostępnego okna przeglądarki. W przypadku wysokości natomiast nie jest to już tak
				proste, bo rodzic nie ma domyślnej wartości, do której moglibyśmy się odnieść, a wysokość okna zależy od
				zawartości elementów, co może być zmienne. Jeśli chcemy wysokość jakiegość elementu określić procentowo,
				to musimy zdefiniować wysokość dla wszystkich elementów nadrzędnych, w których dany element jest
				zagnieżdżony. W przypadku div'a zagnieżdżonego bezpośrednio w body, aby określić jego procentową
				wysokość, musimy określić wysokość body oraz naszego root'a, czyli html np. jako 100% albo w pikselach.
				Generalnie jednak nie definiujemy wysokości w ten sposób jak na podanym przykładzie, jest to bardzo
				ekstremalny przypadek.<br>
				<img class="image" src="height-in-percent.jpg"
					alt="Przykład treści ostylowanej za pomocą wysokości zdefiniowanej w procentach." /><br>
				Jeśli natomiast będziemy mieć element zawarty w innym elemencie, którego wysokość i szerokość zostały
				zdefiniowane, do nadając temu zagnieżdżonemu elementowi wysokość i szerokość o wartości 50%, zajmie on
				połowę wysokości i szerokości rodzica, a nie całego body.
				</p>
				<p class="paragraph">
				<h4 class="paragraph-header">Viewport width i viewport height</h4>
				Viewport width (vw) jest to jednostka odnosząca się do szerokości okna, w którym wyświetla się nasz
				dokument. Jednostka ta zawsze działa w kontekście szerokości całego ekranu, czyli nawet jeśli mamy
				element zagnieżdżony w innym elemencie o określonej szerokości, to nadając temu zagnieżdżonemu
				elementowi szerokość 50vw, zajmie on połowę dostępnego ekranu, a nie połowę szerokości rodzica.<br>
				W przypadku jednostki viewport height (vh) jej zastosowanie nie powoduje takich problemów jak
				definiowanie wysokości w procentach. Jednostka vieport height bazuje na wysokości dostępnego okna, w
				którym wyświetla się treść, a nie wysokości całego dokumentu. Czyli jeśli wysokość elementu zdefiniujemy
				na 33vh, to zajmie on 33% dostępnego okna przeglądarki. Jeśli natomiast wysokość elementu zdefiniujemy
				na 100vh, to zajmie on 100% dostępnego okna przeglądarki i by dostać się do treści spoza elementu,
				będziemy musieli się przescrollować. Można w ten sposób np. wykonać pokaz slajdów na stronie.
				</p>
			</article>
			<article class="article">
				<h3 class="article-header">Box model: padding, border i margin</h3>
				<p class="paragraph">

					Wszystkie elementy na stronie internetowej otoczone są niewidzialnym prostokątem, który ma jakąś
					wysokość i szerokość i który możemy podejrzeć, najeżdżąjąc na te elementy za pomocą devtools. Box
					model jest to zatem opis wymiarów naszego elementu, który składa się z kilku wartości:<br>
					- element - znajduje się w środku i ma określoną wysokość i szerokość;<br>
					- padding - jest to wewnętrzny margines, który definiuje, jaka ma być odległość między treścią,
					zawartością naszego elementu a ramką tego elementu;<br>
					- border - ramka elementu, zamyka element;<br>
					- margin - nie jest już częścią elementu, ale definiuje jego zachowanie, określa o ile nasz element
					ma być oddalony od innych elementów i o ile te inne elementy mają być oddalone od naszego
					elementu.<br>
					Box model dla danego elementu można podejrzeć w devtools. Wartości są tam opisane w pikselach.<br>
					<img class="image" src="box-model.jpg"
						src="Box model składający się z elementu, paddingu, borderu i marginu." />
				</p>
				<p class="paragraph">
				<h4 class="paragraph-header">Padding</h4>
				Padding, czyli wewnętrzny margines, jest własnością, która posiada kilka wartości. Można go opisać w
				sposób pełny, podając odległość od treści elementu od ramki po stronie lewej, prawej oraz od góry i
				dołu, opisując każdą z wartości osobno i definiując je w sposob jawny. Można również dokonać zapisu
				skrótowego (shorthand), bez opisywania każdej strony osobno, podając same wartości dla paddingu według
				określonej kolejności, zgodnie z ruchem wskazówek zegara: góra prawo, dół, lewo. Jeśli natomiast padding
				będzie miał przypisaną tylko jedną wartość, to będzie ona miała zastosowanie do wszystkich czterech
				stron. Innymi słowy, jeśłi wszystkie wartości paddingu są takie same, to wystarczy opisać padding za
				pomocą tej jednej wartości (np. padding: 10px), bez wyszczególniania padding-bottom, padding-top,
				padding-left, padding-right.<br>
				<img class="image" src="padding-description.jpg"
					alt="Przykład zapisu pełnego i skróconego dla paddingu." /> <br>
				Padding można opisać również za pomocą tzw. wartości lustrzanych, jeśli chcemy, by wartości góra/dół
				oraz prawo/lewo, były takie same. Możemy podać w takiej sytuacji dla paddingu tylko dwie wartości i
				wówczas zostaną one dobrane parami - pierwsza zostanie przypisana do odległości góra/dół, z kolei druga
				dla stron prawo/lewo.<br>
				<img class="image" src="padding-mirror-values.jpg"
					alt="Przykład zapisu wartości lustrzanych dla paddingu." /><br>
				</p>
				<p class="paragraph">
				<h4 class="paragraph-header">Border</h4>
				Podobnie jak padding, border również może być opisany w sposób pełny i zawierający definicje wszystkich
				własności lub w sposób skrótowy (shorthand), gdzie wszytskie wartości są wrzucone do jednej własności o
				nazwie border. Border może być opisany za pomocą wartości:<br>
				- border-width - opisuje szerokość ramki;<br>
				- border-style - opisuje styl ramki, wartość ta musi być podana, by ramka się w ogóle pojawiła;<br>
				- border-color - opisuje kolor ramki.<br>
				Jeśli dany element zostanie ostylowany podwójnie, np. za pomocą opisu pełnego i skrótowego, gdzie będą
				podane różne wartości, to zgodnie z ogólnymi regułami specyficzności, zastosowanie będzie miał styl
				znajdujący się niżej w pliku, czyli ten, który de facto jest bliżej danego elementu.<br>
				Ramka nie musi znajdować się po każdej ztronie elementu, możemy sobie zdefiniować, po której stronie
				chcemy ją umieścić, opisując ją za pomocą wartości border-bottom, border-left, border-top, border-right,
				definiując tylko tę stronę, po której chcemy mieć ramkę. Jeśli natomiast damy definicję ogólną dla
				border, to style poszczególnych stron ramki możemy sobie nadpisywać dodając definicje np. dla border-top
				i border-bottom. W podanym przykładzie ramka po stronie lewej i prawej będzie ostylowana według
				definicji ogólnej, natomiast góra i dół ramki zostaną ostylowane według definicji szczegółówych
				określonych w sposób jawny dla border-bottom i border-top.<br>
				<img class="image" src="border-description.jpg"
					alt="Własność border opisana w sposób pełny i skrótowy." /><br>
				Do ramki można dodać również efekt zaokrąglenia za pomocą wartości <strong>border-radius</strong>. Żeby
				skorzystać z tego efektu nie musimy wcale mieć definicji dla ramki - w takiej sytuacji zaokrąglony
				zostanie sam element. Border-radius opisujemy za pomocą pikseli lub procentów. Jeśli określimy, ze
				border-radius: 100%, to dany element zostanie zaokrąglony na całej długości i szerokości. Border-radius
				można również wykorzystać do zrobienia kółka za pomocą CSS. Aby uzyskać taki efekt, element musi mieć
				taką samą wysokość i szerokość i definiujemy dla niego border-radius: 100%.<br>
				<img class="image" src="border-radius.jpg"
					alt="Przykłady elementów ostylowanych za pomocą własności border-radius." />
				</p>
				<p class="paragraph">
				<h4 class="paragraph-header">Margin</h4>
Marginesy zapisujemy tak samo jak padding. Marginesy zewnętrzne nakładają się na siebie, co zonacza, ze jeśli mamy obok siebie dwa elementy i dla jednego zdefiniujemy margin: 100px, a dla drugiego margin: 120px, to odległóść między tymi elementami wyniesie 120px, a nie 220px. Dla marginesów występują również wartości lustrzane, które wykorzystywane są często by wyśrodkować dany element. By uzyskać taki efekt do własności margin dodajemy dwie wartości - odstęp oraz auto, np. margin: 50px auto. Jeśli element zajmuje całą dostępną szerokość okna, to będzie po prostu oddalony o krawędzi okna o wartość zdefiniowaną dla margin, jeśli jednak szerokość elementu jest mniejsza niż dostępne okno przeglądarki, to wartość auto sprawi, że element zostanie wyśrodkowany. Jeśli dany element jest zagnieżdżony w innym divie, to w takim przypadku będzie centrowany nie do dostępnego omna, ale w ramach swojego rodzica, nadrzędnego diva.<br>
<img class="image" src="margin-auto.jpg" alt="Element wyśrodkowany za pomocą wartości auto zdefiniowanej dla marginesu."/>
				</p>
			</article>
			<article class="article">
				<h3 class="article-header">Box sizing - content-box versus border-box</h3>
				<p class="paragraph">
					Domyślny box sizing to content-box, czyli definicja szerokości i wysokości elementu odnosi się do samego contentu, nie obejmuje paddingu i borderu. Jeśli zatem zmniejszymy lub zwiększymy padding i/lub border, to wpłynie to również na wielkość samego elementu.<br>
					Box sizing może być jednak również określany przez wartość border-box, gdzie definicja wysokości i szerokości elementu odnosi się do całego elementu i oprócz contentu obejmuje również padding i border. Aby było to mozłiwe, należy dla danego elementu lub grupy elementów dodać własność box-sizing: border-box. Definiowanie wielkości elementów w ten sposób pozwala przewidzieć, jak duży będzie element, bez względu na to, jaką wartość będzie miał jego padding czy border. Wielkość conetentu elementu jest tu wyliczana automatycznie, po odjęciu od wysokości i szerokości całego elementu, wartości paddingu i borderu. Wartość border-box jest obecnie stosowana jako rozwiązanie standardowe dla określania box sizing.<br> 
					Zarówno w przypadku content-box, jak i border-box, wielkość marginesu nie wpływa na wielkość elementu, gdyż margines znajduje się już poza elementem.<br>
					<img class="image" src="box-sizing.jpg" alt="Porównanie elementów określonych za pomocą content-box i border-box."/><br>
					Jeśli mamy dwa elementy, z których jeden jest ostylowany za pomocą border-box, a drugi za pomocą content-box i chcemy, by oba miały taką samą wysokość i szerokość równą 200px, padding o wartości 40px i border równy 20px, to w przypadku elementu ostylowanego za pomocą box-sizing: border-box, wystarczy, że określimy dla tego elementu width i height, definiując dla nich wartość 200px i podamy wartości dla padding i border zgodne z powyższymi. Z kolei element ostylowany za pomocą box-sizing: conent-box, który ma padding równy 40px i border równy 20px, by uzyskać wielkość 200px, musi mieć wysokość i szerkość 80px (80px sam conent plus 2x40px paddingu i 2x20px borderu daje w sumie 200px dla całego elementu).
				</p>
			</article>
			<article class="article">
				<h3 class="article-header">Position i float</h3>
				<p class="paragraph">
					<h4 class="paragraph-header">Position: static</h4>
					Własność position: static oznacza, że to przeglądarka decyduje, gdzie dany element umieścić, wyliczając to sobie na podstawie zdefiniowanych stylów dla elementów na stronie (czy blok, czy inline, odległości, etc.). Jest to wartość domyślna, znajduje zastosowanie, gdy nie ma określonej wprost wartości dla position. Można ją jednak również określić jawnie. 
				</p>
				<p class="paragraph">
					<h4 class="paragraph-header">Position: relative, position: absolute</h4>
					Własność position: relative pozwala na stworzenie przestrzeni, względem której możemy umieszczać inne elementy. Po dodaniu tego stylu wygląd elementu się nie zmienia, ale stworzona za jego pomocą przestrzeń umożliwia wykorzystanie własności position: absolute.<br> 
					Position: absolute pozwala na pozycjonowanie względem elementu, który ma zdefiniowaną pozycję relative. Element z pozycją absolute może być przesuwany po stworzonej warstwie względem rodzica, który jest w pozycji relative za pomocą wartości top, right, bottom, left. Pozycja jest liczona od krawędzi elementu, nie uwzględniając bordera.<br>
					<img class="image" src="position-absolute.jpg" alt="Przykład elementu ostylowanego za pomocą position: absolute."/>
				</p>
				<p class="paragraph">
					<h4 class="paragraph-header">z-index</h4>
					Jeśli dwa elementy mają zdefiniowaną tę samą pozycję, to widoczny na wierzchu jest ten, którego definicja stylu znajduje się bliżej końca pliku, czyli ten, który renderuje się później (renderowanie - proces przekształcania kodu i danych w finalną postać, która jest widoczna i interaktywna dla użytkownika. Polega na konwersji abstrakcyjnych danych w konkretne elementy graficzne lub wizualne reprezentacje). W takiej sytuacji umiejscowieniem elementu można sterować za pomocą własności z-index, która odpowiada za warstwowanie - im wyższa wartość z-index, tym dany element jest wyżej. Do pozycjonowania staramy się używać sensownych, niezbyt dużych liczb (np. z-index: 10;) i zwiększać je powoli. Wóczas zastosowanie dużej liczby, np. 1000 sprawi, że elementy wypozycjonowane niżej znajdą się pod spodem i nie będą zasłaniały wybranego elementu.<br>
					<img class="image" src="z-index.jpg" alt="Przykład warstwowania elementów za pomocą własności z-index."/><br>
					Warstwowanie elementów na stronie jest dobrze zobrazowane w przeglądarce Edge. Po uruchomieniu w devtools za pomocą skrótu ctrl + shift + p panelu wyszukiwania należy wpisać i wybrać '3d view' i wówczas pojawi się zakładka, w której możemy podejrzeć naszą stronę w ujęciu trójwymiarowym. Widok można obracać stosując strzałki widoczne w oknie. Jedną z opcji widoku jest z-index, gdzie można podejrzeć jak elementy układają się na warstwach według zdefiniowanych wartości z-index.<br>
					<img class="image" src="3Dview.jpg" alt="Widok okna 3d view w narzędziach developerskich na przeglądarce Chrome."/><br>
					Panel 3D view posiada również zakładkę DOM, w której można podejrzeć zagnieżdżenia elementów na stronie w ujęciu trójwymiarowym, czyli jak strona jest zbudowana.
				</p>
				<p class="paragraph">
					<h4 class="paragraph-header">Position: fixed</h4>
					Własność position o wartości fixed pozwala na przyklejenie elementu do viewportu, czyli widocznego okna przeglądarki. Ostylowany w ten sposób element wyskakuje z pudełka i przykleja się w zdefiniowanym miejscu przeglądarki. Jeśłi nadamy takiemu elementowi dodatkowo z-index o wartości ujemnej, np. -1, to scrollując treści w oknie przeglądarki, będzie on się cały czas przesuwał, by być widoczny w viewport, ale będzie się chował pod innymi elementami, które domyślnie mają przypisaną wartość z-index: 0. Wartość fixed jest często używana w urządzenianiach mobilnych, np. do przyklejenia przycisku menu.<br>
					<img class="image" src="position-fixed.jpg" alt="Przykład ostylowania elementu za pomocą własności position: fxed."/>
				</p>
				<p class="paragraph">
					<h4 class="paragraph-header">Position: sticky</h4>
					Wartość sticky jest bardzo przydatka, np. gdy mamy dłuższe treści i chcemy przykleić nagłówek wewnątrz danego kontenera. Należy mieć jednak na uwadze, ze styl sticky nie zadziała, jeśli rodzic danego elementu ostylowanego w ten sposób ma przypisaną własność własność overflow. Dodatkowo, element, któremu nadajemy własność sticky musi zostać jakoś umiejscowiony w kontenerze względem viewport, np. za pomocą własności top: 0. W tym przypadku element sticky przyklei się do góry strony i gdy będziemy scrollować stronę, zostanie cały czas w tym samym miejscu aż do momentu, gdy wyjdziemy z danego elementu rodzicielskiego, wówczas nie będzie się już dalej przesuwał i zniknie z viewport razem z całym kontenerem. Sticky bowiem działa tylko wewnątrz danego rodzica. Można go wykorzystać np. gdy mamy dłuższy tekst i chcemy, by nagłówki się przyklejały w pewnym momencie przy scrollowaniu dalszej części tekstu. Odległość od góry strony można oczywiście określić według potrzeb.<br>
					<img class="image" src="position-sticky.jpg" alt="Przykład ostylowania elementu za pomocą własności position: sticky."/><br>
					Do niedawna, zanim powstała własność position: sticky, ten sposób ostylowania elementu trzeba było kodować w JS. Ponadto, w odróżnieniu od wartości absolute, która żyje swoim życiem i nie zmienia treści elementu, wartość sticky stanowi element treści i zachowuje się tak, jak cała reszta treści, dopóki nie zaczniemy scrollować. W związku z tym nie musimy podawać dla sticky dodatkowych paddingów i marginesów, Przeglądarka sama sobie to wyliczy. Wystarczy podać jakąś wartość top, a w przypadku stron scrollowanych w poziomie, jakąś odległość left lub right.
				</p>
				<p class="paragraph">
					<h4 class="paragraph-header">Float</h4>
					Element ostylowany za pomocą wartości float zachowuje się w ten sposób, że jest opływany przez treść, która znajduje się po nim. Float może przykleić nasz element do lewej strony (float: left;) lub prawej (float: right;).
					Kiedyś stylowanie za pomocą float było bardzo popularne jako technika budowania stron internetowych, ale obecnie Maciek go nie rekomenduje. Można go wykorzystać do rozrzucania tekstu np. do wrzucenia w treść obrazka, ostylowania jakiegoś obrazka w taki sposób, by był opływany przez tekst. <strong>Float nie służy do budowania layoutów.</strong> Obecnie wykorzystywane są do tego nowoczesne techniki, które będą omówione później.<br>
					<img class="image" src="float.jpg" alt="Elementy ostylowane za pomocą własności float."/>
				</p>
				<p class="paragraph">
					<h4 class="paragraph-header">Clear</h4>
					Własność clear czyści nam floaty. Jeśli do kontenera div, w którym znajdują się elementy mające zdefiniowaną własność float, dodamy kolejnego diva ostylowanego za pomocą własności clear, to wyczyści on floaty zdefiniowane w ramach tego samego diva rodzicielskiego (clear: both). Elementy o wartości float nadal będą przyklejone do lewej lub prawej, ale tekst spadnie poniżej. Sam div ostylowany za pomocą clear nie jest widoczny bezpośrednio na stronie, wpływa jedynie na inne elementy.<br>
					<img class="image" src="clear.jpg" alt="Przykład użycia własności clear."/>
				</p>
			</article>
			<article class="article">
				<h3 class="article-header">Normalizacja vs reset</h3>
				<p class="paragraph">
					<h4 class="paragraph-header">Domyślne style przeglądarki</h4>
					Normalizacja i reset to metody ujednolicania stylów. Przeglądarki internetowe posiadają bowiem swoje style domyślne, które nadają wszystkim elementom na stronie. Można je podejrzeć w devtools, na przykładzie poniżej są opisane jako "user agent stylesheet".<br>
					<img class="image" src="browser-default-styles.jpg" alt="Podgląd domyśnych stylów przeglądarki w devtools."/>
				</p>
				<p class="paragraph">
					<h4 class="paragraph-header">Reset</h4>
					
				</p>
			</article>
		</section>

	</main>
	<footer class="footer">Strona domowa Magdaleny Derek, wszystkie treści są wynikiem nauki w ramach szkolenia WTF: Co
		ten frontend.
		<a class="footer-link" href="#top">Wróć na górę strony ⬆️</a>
	</footer>
	<script src="main.js"></script>
</body>

</html>