<!DOCTYPE html>
<html lang="pl">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Notatki z frontendu</title>
	<link href="/normalize.css" rel="stylesheet" type="text/css">
	<link href="/style.css" rel="stylesheet" type="text/css">
</head>

<body class="body">
	<header class="header">
		<nav class="navigation">
			<a class="navigation__link" href="/index.html">Strona główna</a>
			<a class="navigation__link" href="/nauka-html.html">Nauka HTML</a>
			<a class="navigation__link" href="/nauka-css.html">Nauka CSS</a>
			<a class="navigation__link" href="/nauka-js.html">Nauka JavaScriptu</a>
			<a class="navigation__link" href="/nauka-varia.html">Nauka - varia</a>
		</nav>

	</header>
	<main class="main">
		<header>
			<h1 id="top" class="main__header">Nauka JavaScriptu</h1>

		</header>
		<div class="section-grid">
		<section class="section">
			<h2 class="section__header">JavaScript - tydzień 2 i 3</h2>
			<article class="article">
				<h3 class="article__header">Podstawy</h3>
				<p class="article__paragraph">
					JAVA SCRIPT – umożliwia interakcje
				</p>
				<p class="article__paragraph">
					ECMAScript - skryptowy język oprogramowania, ustandaryzowany przez organizację ECMA, ECMAScript
					Language Specification.<br>
					ECMA - European Association for Standardizing Information and Communication Systems jest to
					organizacja, której zadaniem jest tworzenie standardów technologicznych.<br>
					Co roku jest aktualizowany, w kursie wykorzystywany ES6+ dla roku 2015+ i nowszych, do 2020
					włącznie. JavaScript implementuje rzeczy ze specyfikacji ECMAScript.
					Nowo wprowadzone feature'y, funkcje języka, mogą nie być wspierane we wszystkich przeglądarkach, które też muszą wprowadzać nowe wersje, żeby gonić standardy, ale
					można to obejść.
				</p>
				<p class="article__paragraph">
					JavaScript jest obiektowym językiem programowania i składa się z następujących elementów:<br>
					- wartości,<br>
					- zmienne,<br>
					- funkcje,<br>
					- literały,<br>
					- obiekty,<br>
					- operacje porównywania.
				</p>
				<p class="article__paragraph">
					Wartości są dla JS tym, czym liczby dla matematyki - jest to pewien zbiór, który już istnieje, nie
					tworzymy go.
					Wartością może być np. jakaś liczba, słowo. Są one niezmienialne.
				</p>
				<p class="article__paragraph">
					Pliki zawierające kod JavaScript mają rozszerzenie .js. Podobnie jak style mają też swój znacznik
					"script".<br>
					Znacznik "script" dodajemy na samym dole strony, po stopce "footer", tuż przed domknięciem znacznika
					"body".<br>
					Przykładem może być funkcja alert, która składa się z nazwy funkcji, nawiasów otwartych oraz
					znajdujących się w nawiasie parametrów w pojedynczych apostrofach (zamiast pojedynczych apostrofów, można dać podwójne - cudzysłów, to też zadziała). Na końcu dajemy średnik ;
					oznaczający zakończenie linii.<br>

				</p>
				<img class="image" src="/tag-script.JPG"
					alt="Przedstawienie umiejscowienia znacznika script z funkcją alert przed domknięciem znacznika body." />
				<p class="article__paragraph">
					Skrypt wykonuje się tylko raz, jeszcze przed załadowaniem strony. W przypadku funkcji alert jest to
					wyskakujące okienko zawierające treść podaną w parametrach funkcji.
				</p>
				<img class="image" src="/alert-example.JPG"
					alt="Przykład działania funkcji alert na stronie - wyskakujące okienko." />
				<p class="article__paragraph">
					Tak, jak w przypadku stylów, bezpośrednie pisanie kodu JavaScript w pliku z htmlem zadziała, ale
					jest mało praktyczne, dlatego stosuje się wydzielanie kodu JavaScript do osobnego pliku, np.
					main.js.<br>
					W pliku zawieramy po prostu bezpośrednio treść naszego kodu JavaScript w kolejności, w jakiej ma być
					wykonywany.<br>
					Odniesienie do pliku z kodem JavaScript umieszczamy na końcu strony, przed domknięciem znacznika
					body, używając znacznika "script".
					Używamy atrybutu "src", tak jak w obrazkach, a nie "href", tak jak w przypadku stylów.
				</p>
				<img class="image" src="/main-file.JPG" alt="Odwołanie do pliku z kodem JavaScript w pliku HTML." />
				<p class="article__paragraph">
					Kolejnym poleceniem jest funkcja console.log, która w przeciwieństwie do funkcji alert nie wyświetla
					informacji na stronie, ale w narzędziach deweloperskich w zakładce "console".<br>
					Funkcja console.log pozwala na wyświetlenie określonego tekstu lub wartości, np.:<br>
					console.log('tekst');<br>
					Jeśli wpisze się funkcję dwa razy, to zostanie ona wywołana dwukrotnie.
				</p>
				<img class="image" src="/consolelog-example1.JPG"
					alt="Przykład dwukrotnego wywołania funkcji console.log w konsoli w narzędziach deweloperskich w przeglądarce." />
				<p class="article__paragraph">
					Zmienna w JavaScript to stworzenie powiązania między nazwą, której chcemy użyć a wartością, którą chcemy
					przypisać tej zmiennej.<br>
					const name = 'Magdusia';<br>
					const age = 38;<br>
					Zmiennej o nazwie "name" przypisujemy wartość słowną "Magdusia", używając apostrofów. Zmiennej o nazwie "age"
					przypisujemy wartość liczbową "38", nie używając apostrofów.<br>
					Przy tworzeniu zmiennych nie trzeba dawać średnika na końcu linii, przeglądarka to przetworzy. Jednak dla
					dobrej praktyki lepiej to robić, żeby zaznaczyć w ten sposób koniec linii.<br>
					Wywołując nazwę zmiennej w funkcji nie używamy apostrofów.<br>
					<img class="image" src="/consolelog-example2.JPG"
						alt="Stworzenie zmiennej słownej i liczbowej oraz ich wywołanie w funkcji console.log." />

				</p>
				<p class="article__paragraph">
					Backtick/backquote (`) - przetrącony apostrof, na klawiaturze znajduje się tam, gdzie tylda ~.<br>
					Używamy go, jeśli chcemy wykorzystać w jakiejś funkcji jednocześnie zmienną i tekst - taki ciąg znaków
					nazywamy <b>literałem</b>.<br>
					console.log(`Nazywam się ${firstName} i mam ${age} lat.`);
				</p>
				<img class="image" src="/consolelog-example3.JPG"
					alt="Wykorzystanie w funkcji console.log jednocześnie zmiennej oraz tekstu, czyli literału." />
				<p class="article__paragraph">
					Kod JS uruchamia się raz (po załadowaniu strony). Może też oczywiście działać później, jeśli ma odpowiednie
					instrukcje.
				</p>
			</article>
		</section>
		<section class="section">
			<h2 class="section__header">JavaScript - tydzień 4</h2>
			<article class="article">
				<h3 class="article__header">Typy i struktury danych, immutability</h3>
				<p class="article__paragraph">
					Zmienne w Java Script możemy zadeklarować (stworzyć) za pomocą trzech słów kluczowych: LET, CONST i VAR, omówionych poniżej.
				</p>
				<p class="article__paragraph">
					<h4 class="paragraph-header">LET</h4>				
					LET - zmienne, które definiujemy tylko raz, ale których połączenie możemy przepinać, w wyniku czego można zmieniać przypisaną danej zmiennej wartość tak, jak w przykłądzie poniżej. Po utworzeniu zmiennej za pomocą słowa kluczowego LET, możemy później za pomocą tej zmiennej wskazywać na inne wartości, zmieniać je.<br>
					let isHappy = false;<br>
					isHappy = true;<br>
					isHappy = 'tak';<br>
					<img class="image" src="/let-variable.jpg" alt="Przykład definiowania zmiennej za pomocą słowa kluczowego let."/>
				</p>
				<p class="article__paragraph">
					<h4 class="paragraph-header">CONST</h4>	
					CONST - tworzy zmienne, które mają stałe połączenie z jedną wartością, tak jak w definicjach poniżej. Jeśli będziemy próbowali przypisać do zmiennej age lub name jakąś inną wartość (np. age = 25), to otrzymmay błąd.<br>
					const name = 'Magdalena';<br>
					const age = 39;<br>
					<img class="image" src="/constant-variable.jpg" alt="Przykłady definiowania zmiennych za pomocą słowa kluczowego const."/>
				</p>
				<p class="article__paragraph">
					<h4 class="paragraph-header">VAR</h4>	
					VAR - obecnie definiowanie zmiennych za pomocą tego słowa kluczowego wychodzi z użycia.
				</p>
				<p class="article__paragraph">
					<h4 class="paragraph-header">Definiowanie zmiennych - przykłady</h4>	
					Poniżej znajdują sie dwa przykłady definiowania zmiennych. W pierwszym definiujemy zmienną x za pomocą CONST, przypisując jej wartość 10. Następnie definiujemy zmienną y za pomocą LET, przypisując jej wartość x. Po wykonaniu tego kodu, obie zmienne, x i y będą równe 10. Gdy zmiennej y przypiszemy następnie inną wartość, 20, to po wykonaniu kodu, zmienna y będzie miała wartość 20, ale zmienna x nadal będzie miałą wartość 10.<br>
					W drugim przykładzie odwracamy sytuację i definiujemy zmienną a za pomocą LET, przypisując jej wartość 20, a następnie definiujemy zmienną b za pomocą CONST, przypisując jej wartość a. Po wykonaniu kodu, obie zmienne będą miały wartość 20. Jeśli następnie zmiennej a przypiszemy inną wartość, 13, to po wykonaniu kodu, zmienna a będzie miała wartość 13, ale zmienna b nadal będzie miała wartość 10.<br>
					Dzieje się tak, ponieważ kod wykonuje się tylko raz. Wartość do zmiennej x w przykładzie pierwszym i zmiennej b w przykładzie drugim przypisujemy tylko w momencie pierwszego wykonania kodu. Wartość jest do nich przypisywana w momencie definiowania tych zmiennych. To, że następnie wartości zmiennych y i a ulegają zmianie, z punktu widzenia zmiennych x i b nie ma znaczenia. Powiązanie zostało bowiem wykonane wcześniej, gdy miały one inne wartości. W przykładach tych nie dokonujemy powiązania między zmiennymi ani między wartościami. Przypisujemy jedynie wskazanie na wartość, jaką wskazywała dana zmienna w momencie jej tworzenia.<br>
					<img class="image" src="/variables-definition-example1.jpg" alt="Przykład pierwszy definiowania zmiennych za pomocą const i let."/><br>
					<img class="image" src="/variables-definition-example2.jpg" alt="Przykład drugi definiowania zmiennych za pomocą const i let."/><br>
				</p>
				<p class="article__paragraph">
					<h4 class="paragraph-header">Typy proste w JS</h4>	
					Java Script jest językiem nietypowanym, co oznacza, że jako wartość zmiennej można podpiąć absolutnie wszystko. Typy w innych językach oprogramowania określają, jaki rodzaj wartości można podpiąć do zmiennej. Jednak pomimo tego, że jest to język nietypowany, Java Script posiada typy proste (primitives), czyli rodzaje wartości, które obejmują:<br>
					- string - tekst, który otaczamy za pomocą podwójnego apostrofu ", pojedynczego apostrofu ' lub kopniętego apostrofu ` (do zwykłych tekstów, w których nie używamy dodatkowych zmiennych, Maciek zaleca korzystanie z pojedynczych apostrofów);<br>
					- number - liczba;<br>
					- bigint - duża liczba, większa niż 2 do potęgi 53;<br>
					- boolean - true lub false, prawda lub fałsz, typ ten jest wykorzystywany do tworzenia logiki w JS, sprawdzania warunków etc.;<br>
					- null - wartość celowo niezdefiniowana, wiemy, że powinna być jakaś wartość, ale jej nie ma i celowo oznaczamy, że jej nie ma, ale sama zmienna jest zdefiniowana; wartość zapisujemy bez żadnych apostrofów, gdyż nie jest to wartość jako taka, ale typ wartości;<br>
					- undefined - brak definicji, dana zmienna nie została w ogóle zadeklarowana;
					- symbol - typ wartości wykorzystywany do tworzenia "unikalnych opakowań", raczej nie jest wykorzystywany, wymieniony został bardziej jako ciekawostka.<br> 
					<img class="image" src="/primitives-in-js.jpg" alt="Lista typów prostych w Java Script."/>
				</p>
				<p class="article__paragraph">
					<h4 class="paragraph-header">Instrukcja typeof</h4>	
					To, jaki typ ma dana zmienna możemy sprawdzić za pomocą instrukcji typeof. Instrukcja ta nie zawsze zwraca poprawny typ, którego się spodziewamy w danym przypadku. Na przykładzie podanym poniżej, przy sprawdzaniu typu zmiennej, do której została przypisana wartość null, typeof zwraca object zamiast null. Dzieje się tak dlatego, że w Java Script, jako języku obiektowym, wszystko jest obiektem, a null jest wskazaniem na pusty obiekt, w którym w przyszłości ma się znaleźć jakaś inna wartość.<br>
					<img class="image" src="/typeof-instruction-examples.jpg" alt="Przykłady sprawdzania typu zmiennych za pomocą instrukcji typeof."/>
				</p>
				<p class="article__paragraph">
					<h4 class="paragraph-header">Immutability</h4>	
					Immutability, czyli niemutowalność, jest to jeden z fundamentalnych konceptów Java Script. Oznacza, że nie można zmieniać wartości primitive values w Java Script. To, co zmieniamy, to połączenie między tymi wartościami a zmiennymi. Sam wszechświat wartości jest niezmienny. Nasze zmienne nie mogą ich modyfikować i sprawić, że np. 20 to będzie 13.
				</p>
			</article>
			<article class="article">
				<h3 class="article__header">DOM - document object model</h3>
				<p class="article__paragraph">
					DOM (obiektowy model dokumentu) to jest to, co widzimy w devtools w zakładce Elements. Nie jest to plik z kodem HTML w edytorze ani jako źródło naszej strony. DOM w devtools ma się tak do pliku z kodem HTML jak gotowy skręcony mebel do instrukcji jak go skręcić. Kod HTML jest to zatem instrukcja, która jest następnie interpretowana przez przeglądarkę i wyświetlana w postaci DOM. DOM jest zatem "złożonym" w przeglądarce kodem HTML. 
				</p>
				<p class="article__paragraph">
					DOM stanowi pomost pomiędzy kodem HTML a JavaScriptem. DOM może być bowiem przez JavaScript modyfikowany. Powstał po to, by można było modyfikować strony internetowe, operować na nich za pomocą JavaScriptu, by odnosząc się do nich dodać np. interakcje. Podobnie jak w CSS, żeby odnieść się do danego elementu używamy selektorów w postaci klas czy id, tak w przypadku JavaScriptu funkcję tę pełnią query selektory. Query selector jako parametr wykorzystuje te same selektory wskazujące na dany element, które stosowane są w CSS. Za pomocą querySelector wybieramy zatem węzły w HTML, by móc na nich operować (w naszym przykładzie modyfikacje nagłówka h1). Funkcja querySelector zwraca zatem node (węzeł) z HTML-a.
				</p>
				<img class="image" src="/query-selector.jpg" alt="Funkcja wykorzystująca query selectory."/><br>
				<p class="article__paragraph">
					Odpowiednikiem powyższego zapisu funkcji w jQuery, który obecnie stanowi już raczej ciekawostkę i element legacy, jest zapis z użyciem dolara: $('.selector').
				</p>
				<p class="article__paragraph">
					Do oznaczania elementów za pomocą specjalnej klasy, która będzie się odnosiła tylko do JavaScriptu wykorzystywana jest właśnie konwencja nazewnicza BEM: block__element--js.
				</p>
				<p class="article__paragraph">
					Aby wywołać sobie za pomocą funkcji console.log jakiś element na stronie możemy wykorzystać do tego jakąś zmienną, np. const header, wyszukując ją na stronie za pomocą querySelector. Przy ładowaniu z serwera, przeglądarka może czasem nie zdążyć zaczytać odpowiednio naszego DOM i pliku z kodem JavaScript i wówczas w devtools w Console przy wywołaniu danej funkcji, zamiast wyświetlenia wywołanego za pomocą funkcji elementu, pojawia się węzeł z pulą możliwych funkcji do wykorzystania na naszym elemencie. Można tam podejrzeć również tekst, kod html czy style naszego elementu, czyli cały pojedynczy węzeł naszego DOM, który widzi nasza przeglądrka (na naszym przykładzie jest to element h1). Nie wpływa to jednak na funkcjonalność strony, bo sam skrypt wykona nam się poprawnie, jest to tylko kwestia wizualnej reprezentacji tego obiektu. 
				</p>
				<img class="image" src="/node.jpg" alt="Węzeł z pulą dostępnych funkcji w zakładce Console w devtools."/>
				<p class="article__paragraph">
					Aby jednak zniwelować szansę na wystąpienie takiej sytuacji i zapewnić, by skrypty wczytywały nam się w odpowiednej kolejności, do linku z odniesieniem do naszego pliku JS w kodzie HTML należy dodać atrybut defer (wpisujemy go po znaczniku script, przed adresem src). Wówczas po wywołaniu funkcji w zakładce Console powinien nam się wyświetlić dany element w takiej samej postaci, w jakiej jest widoczny w zakładce Elements w DOM.
				</p>
				<img class="image" src="/query-selector-example.jpg" alt="Funkcja wywołująca element h1 na naszej stronie za pomocą query selector."/>
				<p class="article__paragraph">
					Jak już zostało wcześniej wspomniane, w celu ułatwienia identyfikacji, do oznaczenia naszego elementu można wykorzystać BEM i dodatkową klasę z modyfikatorem --js. Selektorów takich nie wykorzystujemy do stylowania w CSS. Używamy ich jedynie w JavaScript, dzięki czemu nasze skrypty będą nadal działać nawet wówczas, gdy zdecydujemy się na zmianę stylów CSS czy przeniesienie elementu.
				</p>
				<p class="article__paragraph">
					JavaScript, jako nawyższa wartstwa na naszej stronie, może zmieniać na niej wszystko. Możemy więc zmienić np. treść naszego elementu h1. Mamy już wybrany nasz element za pomocą querySelectora i możemy teraz wykonywać na nim operacje. Możemy w tym celu wykorzystać własność innerHTML, która odpowiada za treść naszego elementu, czyli to co, jaki html znajduje się w środku tego elementu: nazwaZmiennejQuerySelector.innerHTML = 'treść'.
				</p>
				<p class="article__paragraph">
					Działając na naszym przykładzie nagłówka h1 i wywołując w console.log naszą funkcję header, w konsoli wyświetla nam się cały nasz obiekt, który po najechaniu zostaje również podświetlony na stronie w oknie przeglądarki. Jeśli jednak wywołamy sobie header.innerHTML, to w konsoli wyświetli nam się tylko zawartość elementu, jego treść, odnosimy się bowiem do samej wartości. Możemy również tę treść zmienić, podając nową: header.innerHTML = 'Hej'. Jest to przykład, gdy w pliku HTML i w źródle strony będziemy mieć wcześniejszą wartość, natomiast w DOM wyświetli się już nowa treść nagłówka, podmieniona za pomocą JavaScriptu. Czyli przykład różnicy między instrukcją a złożonym meblem. Jako nową treść możemy również podstawić utworzone wcześniej zmienne name i age: header.innerHTML = `Witaj, nazywam się ${firstName} i mam ${age} lat.` Przy tworzeniu stron statycznych nie robimy takich rzeczy, nie wrzucamy treści statycznej za pomocą skryptów, ale już przy korzystaniu z danych zewnętrznych albo danych przeliczanych przez JavaScript będziemy w ten sposób podmieniać dane (np. zmiana licznika, gdy użytkownik kliknie na plus).
				</p>
				<img class="image" src="/inner-html.jpg" alt="Wykonanie skryptu zmieniającego treść nagłówka."/>
				<p class="article__paragraph">
					Za pomocą skryptów JS możemy również modyfikować style. Jeśli wywołamy sobie console.log dla naszego elementu header, podając własność style (console.log(header.style)), to w devtools w zakładce Console wyświetli nam się obiekt CSSStyleDeclaration, gdzie po rozwinięciu bedą widoczne wszystkie możliwe własności CSS, dostępne style, jakie możemy wykorzystać w danym elemencie. Możemy te własności modyfikować, przypisać za pomocą tego obiektu. Aby zmodyfikować kolor, podajemy tę własność z nową wartością, jaką chcemy nadać alementowi, np. header.style.color = 'red'. Jeśli podejrzymy sobie strukturę DOM w zakładce Elements w devtools, to widzimy, że JavaScript, wykonując skrypt po prostu dokłada zmieniający kolor styl inline przy nagłówku h1. W pliku HTML oczywiście nie będzie on widoczny. Wprowadza to duży bałagan do kodu. Trzymanie się poszczególnych wartsw strony i ich funkcji zapewnia nam przewidywalność zachowania naszej strony. Są jednak oczywiście przypadki, gdy takie modyfikacje mogą się nam przydać.
				</p>
				<img class="image" src="/css-style-declaration.jpg" alt="Wykonanie skryptu zmieniającego kolor nagłówka."/>
			</article>	
		</section>
		<section class="section">
			<h2 class="section__header">JavaScript - tydzień 5</h2>
			<article class="article">
				<h3 class="article__header">Funkcje</h3>
				<p class="article__paragraph">
					W matematyce jedną z prostszych funkcji jest funkacja liniowa, gdzie w nawiasie podajemy argument lub więcej arumentów oraz jej wynik.
				</p>
				<img class="image" src="/linear-function.jpg" alt="Wykres funkcji liniowej."/>
				<p class="article__paragraph">
					Mamy tu przykład najprostszej funkcji, składającej sie z nazwy f, argumentu w nawiasie i wyniku funkcji: f(x)=x, gdzie f(2)=2, etc. 
				</p>
				<img class="image" src="/function-definition.jpg" alt="Definicja funkcji liniowej."/>
				<p class="article__paragraph">
					Możemy tutaj wykonywać różne operacje, np. f(x)=x*7, gdzie argument x jest mnożony przez 7 i w efekcie mamy wynik f(1)=7, f(2)=14, etc.
				</p>
				<p class="article__paragraph">
					Funkcję w matematyce definiuje się w ten sposób, że funcja na wejściu dostaje dane, czyli argumenty i dla podanego argumentu zwraca jakąś wartość. Funkcja posiada określony wzór.
				</p>
				<p class="article__paragraph">
					Funkcję w JavaScript definiuje się natomiast w ten sposób, że zamiast f mamy słowo kluczowe function, następnie podajemy nazwę funkcji (tu: calculate), w nawiasie dajemy nazwę naszego argumentu (tu: myNumber), bez żadnego słowa kluczowego typu let czy const. Następnie za pomoca nawiasów klamrowych otwieramy ciało naszej funkcji, gdzie możemy opisać wiele rzeczy. Na koniec, jeśli funkcja ma coś zwracać, to dajemy słówko retur i to, co ma być zwrócone (tu: nasz argument myNumber pomnożony przez 7). Jest to odpowiednik matematycznego zapisu f(x)=x*7.
				</p>
				<p class="article__paragraph">
					Opisując funkcję w JavaScript językiem bardziej programistycznym, mamy deklarację, czyli słowo kluczowe function, następnie mamy parametr, czyli argument oraz słowo kluczowe return i wynik.
				</p>
				<img class="image" src="/function-js.jpg" alt="Definicja funkcji w JavaScript."/>
				<p class="article__paragraph">
					Nazwę funkcji najlepiej zapisać za pomocą camelCase.
				</p>
				<p class="article__paragraph">
					Jeśli stworzymy sobie funkcję zgodnie z powyższym przykładem i nasz parametr myNumber powiążemy z wartością 2, na którym wykonamy operację mnożenia razy 7, to po wywołaniu funkcji za pomocą console.log, otrzymamy w devtools wynik 14.
				</p>
				<img class="image" src="/function-example1.jpg" alt="Przykład zastosowania funkcji z parametrem myNumber o wartości 2."/>
				<p class="article__paragraph">
					Słowo kluczowe może wystąpić, ale nie musi, bo nie każda funkcja musi nam coś zwracać. Jeśli nie zdefiniujemy sobie za pomocą return, co dana funkcja ma zwrócić, to dostaniemy po prostu undefined.
				</p>
				<p class="article__paragraph">
					W ciele funkcji możemy zrobić wiele rzeczy, nie musi nam od razu czegoś zwracać. Możemy wykonywać np. obliczenia, modyfikacje napisów, wywołania innych funkcji etc. Na przykładzie poniżej mamy wywołanie za pomocą console.log funkcji myNumber wewnątrz ciała funkcji oraz zmianę przypisania wartości z myNumber na myNumber plus 3.
				</p>
				<img class="image" src="/function-example2.jpg" alt="Przykład zapisu funkcji z większą ilością operacji."/>
				<p class="article__paragraph">
					Funkcję możemy wywołać również bez użycia console.log, wywołując ją po prostu z określoną wartością przypisaną do jej argumentu. Na poniższym przykładzie wywołując funkcję calculate z przypisaną do argumentu wartością 1 otrzymujemy wynik 4. W devtools widać, że odnosimy się tutaj do linii 17 w pliku, gdzie następuje wywołąnie funkcji za pomocą console.log. Ostatnia linia ciała funkcji, w której stosujemy słowo return, nie zostaje nigdzie użyta, dlatego zapis ten nie wpływa na otrzymany wynik.
				</p>
				<img class="image" src="/function-example3.jpg" alt="Przykład bezpośredniego wywołania funkcji calculate z przypisaną wartością 1."/>
				<p class="article__paragraph">
					Wartość z linii 18 możemy jednak przypisać do zmiennej. Tworzymy zmienną result, do której przypisujemy wartość funkcji caluculate(1). Po wywołaniu zmiennej za pomocą console.log otrzymujemy wynik 28 (do funcji calcultae przypisujemy argument 1, który następnie zwiększamy o 3, a później po jego wywołaniu mnożymy przez 7). W devtools widać, że dwukrotnie otrzymujemy wynik 4. Dzieje się tak dlatego, że funkcja została wywołana zarówno w linii 21, poprzez samo jej wywołanie bez przypisywania nigdzie tego wyniku, jak i następnie w momencie przypisania funkcji calculate z argumentem 1 do zmiennej result.
				</p>
				<img class="image" src="/function-example4.jpg" alt="Przykład przypisania funkcji calculate z wartością 1 do zmiennej result."/>
				<p class="article__paragraph">
					Jeśli do zmiennej result przypiszemy funkcję calculate z argumentem 2, a następnie ją wywołamy, to po wykonaniu otrzymamy wynik 35 (do funcji calcultae przypisujemy argument 2, który następnie zwiększamy o 3, a później po jego wywołaniu mnożymy przez 7). W devtools widać, że funkcja zostaje najpierw wykonana z argumentem z przyisamą wartością 1 w linii 21, a następmnie w momencie jej przypisania do zmiennej result z argumentem o wartości 2 w linii 23.
				</p>
				<img class="image" src="/function-example4.jpg" alt="Przykład przypisania funkcji calculate z wartością 2 do zmiennej result."/>
				<p class="article__paragraph">
					Wracając do porównania funkcji w JavaScript do funkcji matematycznej, możemy podsumować, że: 
				</p>
				<ol class="ordered-list">
					<li class="ordered-list__element">Deklarujemy nazwę funkcji (nie zawsze).</li>
					<li class="ordered-list__element">W środku dokonujemy obliczeń lub wykonujemy zadania.</li>
					<li class="ordered-list__element">Funkcja przyjmuje argumenty (nie musi).</li>
					<li class="ordered-list__element">Funkcja zawsze coś zwraca. Jeśli nie mamy słowa kluczowego return, to wówczas zwraca undefined.</li>
				</ol>
				<p class="article__paragraph">
					Przykładem funkcji bez argumentu może być poniższa funkcja hello, która wywołuje po prostu inną funkcję, wypisującą po prostu "hello" w konsoli w devtools. Jeśłi następnie wywołamy sobie po prostu tę funkcję wpisując jej nazwę, to wykona się i w devtools dostaniemy jako wynik jej wykonania napis hello w konsoli. Wykonują się wtedy te operacje, które są w środku w ciele funkcji hello. Jeśli znajdzie sie tam kilkukrotne wywołanie funkcji console.log, to po wywołaniu funcji hello, wykonają sie wszystkie operacje w niej zawarte. Nie ma return, więc funkcja nic tutaj nie zwraca - jest po prostu skrótem do uruchomienia wielu operacji, które się w niej znajdują.
				</p>
				<img class="image" src="/function-example6.jpg" alt="Przykład zastosowania funkcji bez argumentu."/>
				<p class="article__paragraph">
					Posługując sie dalej tym przykładem, jeśli następnie wywołamy sobie funkcję hello za pomocą console.log, to otrzymamy jako wynik undefined, jako że sama funkcja nic nie zwraca, nie posiada słowa kluczowego return. Mimo tego, że funkcja nic nie zwraca, jako że nie posiada return, to w momencie wywołania jej za pomocą console.log, wykonają się również wszystkie operacje, które są w niej zawarte. 
				</p>
				<img class="image" src="/function-example7.jpg" alt="Wywołanie za pomocą console.log funkcji nie zawierającej słowa kluczowego return."/>
				<p class="article__paragraph">
					Przyczyny powstania funkcji:
				</p>
				<ol class="ordered-list">
					<li class="ordered-list__element">Deklaracja/opakowanie w funkcję kodu, który sie powtarza (DRY - don't repeat yourself).</li>
					<li class="ordered-list__element">Zwiększenie czytelności kodu.</li>
					<li class="ordered-list__element">Ułatwienie wyszukiwania błędów.</li>
					<li class="ordered-list__element">Odpowiedzialność za wykonywanie zadania w jednym miejscu.</li>
				</ol>
				<p class="article__paragraph">
					(Fat) arrow functions =>
				</p>
				<p class="article__paragraph">
					(Fat) arrow functions zostały wprowadzone w ECMAScript 6. Funkcja strzałkowa jest to trochę inny sposób definiowania funkcji. Zamiast korzystać ze słowa kluczowego function, podpisujemy funkcję pod jakąś zmienną, w naszym przykładzie jest to zmienna o nazwie calculate dla której po znaku równości w nawiasie podajemy argumenty i następnie używamy strzałki, po której otwieramy nawias klamrowy, w którym ciało funkcji wygląda już tak samo jak przy definiowaniu funkcji za pomocą słowa kluczowego function.
				</p>
				<img class="image" src="/arrow-function.jpg" alt="Sposób definiowania arrow function."/>
				<p class="article__paragraph">
					Istnieją różnice w działaniu tych funkcji, ale na tym etapie działają one dla nas identycznie.
				</p>
				<img class="image" src="/arrow-function-example.jpg" alt="Przykład zastowania funkcji strzałkowej."/>
				<p class="article__paragraph">
					Plusem arrow functions jest to, że mają trochę skróconą formę zapisu. Jeśli mamy podany tylko jeden argument dla funkcji, w naszym przypadku myNumber, to nie musimy podawać go w nawiasie. Ponadto jeśli w ciele funkcji mamy tylko prostą operację, którą można zapisać w jednej linii, to nie musimy umieszczać jej w ciele funkcji w nawiasach klamrowych. Zamiast tego po strzałce możemy umieścić jednolinijkowy zwrot, tak jakbyśmy podawali return. Samego słowa kluczowego return nie musimy jednak w tym przypadku podawać, będzie ono zastosowane domyślnie.
				</p>
				<img class="image" src="/arrow-function-short.jpg" alt="Skrócony zapis funkcji strzałkowej."/>
				<p class="article__paragraph">
					Po zapisaniu naszej dotychczasowej funkcji w formie skróconej, otzrymujemy prawie dokładnie to samo co wcześniej - z wyjątkiem console.log, ale on nie jest nam potrzebny do liczenia funkcji, pozwala tylko na podejrzenie, co aktualnie znajduje się w środku funkcji.
				</p>
				<img class="image" src="/arrow-function-short-example.jpg" alt="Przykład zastowania funkcji strzałkowej w skróconej formie zapisu."/>
				<p class="article__paragraph">
					Cechy (fat) arrow function:
				</p>
				<ol class="ordered-list">
					<li class="ordered-list__element">Skraca zapis deklaracji funkcji.</li>
					<li class="ordered-list__element">Zwiększenie czytelność (dyskusyjne).</li>
					<li class="ordered-list__element">Nie tworzy nowego kontekstu this, nie ma dostępu do arguments i super.</li>
					<li class="ordered-list__element">Nie stanowi zamiennika tradycyjnej funkcji, ale w większości przypadków nie będzie widać różnicy w ich zastosowaniu (jeśłi nie będzie się korzystać z opcji z punktu 3).</li>
				</ol>
				<p class="article__paragraph">
					Warto w projekcie trzymać się jednego sposobu zapisu funkcji.
				</p>
			</article>
			<article class="article">
				<h3 class="article__header">Obiekty w JS</h3>
				<p class="article__paragraph">
					Prawie wszystko w JavaScript jest obiektem, bo nawet typy proste, mimo, że nie są obiektem, to się tak zachowują. Obiekt jest strukturą danych, sposobem opisu danych. Nie jest to typ prosty. JavaScript, podobnie jak świat, jest obiektowy. Znajdują się w nim obiekty, które możemy opisać za pomocą pewnych własności i które mogą czasem wykonywać jakieś akcje.
				</p>
				<p class="article__paragraph">
					W strukturze danych wykorzystywanych do opisu obiektów, w obiektach, które tworzymy, używamy zapisu składającego się z nawiasów sześciennych i par składających się z klucza i wartości. Każdą taką parę kończymy przecinkiem, dzięki czemu wiemy, gdzie dana para zaczyna się i kończy. Przecinek po ostatniej parze klucz-wartość nie jest konieczny, ale nie jest też błędem.
				</p>
				<img class="image" src="/object-example.jpg" alt="Przykład zastowania par klucz-wartość do opisu obiektu."/>
				<p class="article__paragraph">
					Klucz musi być unikalny w ramach obiektu. Jako wartość natomiast możemy podać prymitywy, funkcje lub kolejne, zagnieżdżone obiekty.
				</p>
				<p class="article__paragraph">
					W świecie obiektowym używamy innych nazw na rzeczy - nie są to zmienne, lecz własności (property). W naszym przykładzie gwiazdy śmierci, własnościami będą klucze, czyli np. średnica (diameter). Podobnie ma się to w przypadku funkcji, w świecie obiektowym nie są to funkcje, lecz metody (methods). Mimo, że wyglądają tak samo i zachowują sie podobnie to nie są to zmienne czy funkcje, tylko własności i metody.
				</p>
				<p class="article__paragraph">
					Po wywołaniu obiektu w kodzie, w konsoli w devtools wyświetlą się informacje o tym obiekcie w parach klucz-wartość. W devtools wyświetla się też pod spodem sekcja prototype doklejona do naszgo obiektu, ale na tym etapie nie będziemy się zajmować prototypami.
				</p>
				<img class="image" src="/object-devtools.jpg" alt="Wywołanie obiektu w kodzie i jego podgląd w devtools."/>
				<p class="article__paragraph">
					Aby dostać się do konkretnej własności naszego obiektu, stosujemy dot notation, z której korzystaliśmy już w funkcji console.log. Jest to odnoszenie się do czegoś poprzez kropkę. Przykładowo, żeby dostać się do średnicy naszego obiektu, wpisujey deathStar.diameter.
				</p>
				<img class="image" src="/dot-notation.jpg" alt="Wywołanie konkretnej własności obiektu za pomocą dot notation."/>
				<p class="article__paragraph">
					Aby wywołać daną metodę zdefiniowaną w ramach obiektu, wpisujemy nazwę obiektu i po kropce nazwę metody. Do metody przekazujemy parametr, na naszym przykładzie jest to cel (target), jako który możemy wpisać sobie string 'alderaan': deathStar.fire('alderaan'). Metodę można wywołąć dowolną ilość razy z różnymi parametrami.
				</p>
				<img class="image" src="/object-method.jpg" alt="Wywołanie konkretnej metody dla obiektu."/>
				<p class="article__paragraph">
					Drugim sposobem dostania się do własności obiektu jest bracket notation, czyli zapis z nawiasami kwadratowymi []. Zamiast podawania kropki, opakowujemy nasze własności w nawiasy kwadratowe. Własności zapisujemy w apostrofach. Czyli zamiast deathStar.diameter będziemy mieć deathStar['diameter'].
				</p>
				<img class="image" src="/bracket-notation.jpg" alt="Wywołanie konkretnej własności obiektu za pomocą bracket notation."/>
				<p class="article__paragraph">
					Jak już było wcześniej wspomniane, w obiekcie mogą być zagnieżdżone inne obiekty. Może zdarzyć się, że klucz w ramach zagnieżdżonego obiektu będzie miał taką samą nazwę jak klucz znajdujący się bezpośrednio w tym obiekcie, w którym znajduje się zagnieżdżony obiekt. Jest to jednak zgodne z zasadą unikalności, bo dotyczy ona tylko danego konretnego obiektu, a w takim przypadku nazwy kluczy będą dotyczyć różnych poziomów. Aby dostać się do własności takiego zagnieżdżonego obiektu, dodajemy kolejną krpkę w zapisie, przechodząc do kolejnego poziomu zagnieżdżenia. Na naszym przykładzie będzie to deathStar.commander.name, gdzie wywołujemy własność name obiektu commander, który jest zagnieżdżony w obiekcie deathStar.
				</p>
				<img class="image" src="/nested-object.jpg" alt="Wywołanie konkretnej własności obiektu zagnieżdżonego w innym obiekcie."/>
			</article>
			<article class="article">
				<h3 class="article__header">Immutability (niemutowalność) w obiektach</h3>
				<p class="article__paragraph">
					We wcześniejszych lekcjach było powiedziane, że immutability oznacza, że nie możemy zmieniać wartości primitive values w JavaScript. To, co zmieniamy, to połączenia między tymi wartościami a zmiennymi. Na poniższym przykładzie mamy definicje 4 zmiennych: dwie liczby i dwa stringi w postaci imion, przy czym jedno z imion jest zdefiniowane za pomocą let, co oznacza, że można zmienić wskazanie zmiennej, podmienić połączenie do wartości, natomiast pozostałe zmienne są zdefiniowane za pomocą słowa kluczowego const.
				</p>
				<img class="image" src="/variables-definition-example3.jpg" alt="Definicja zmiennych za pomocą const i let."/>
				<p class="article__paragraph">
					Obie zmienne liczbowe wskazują na tę samą wartość, 42 - nie mamy tu dwóch wartości 42 lecz jedną, na którą wskazują obie zmienne. Połączenie z imieniem Stefan jest natomiast zdefiniowane za pomocą słowa kluczowego let, a zatem możemy je zmienić i połączyć zmienną z imieniem Maciek. Nie oznacza to, że powstaną dwie wartości Maciek - nadal jest jedna, tylko wskazują na nią dwie zmienne. Stefan nadal istnieje w świecie wartości, ale nie jest połączony z żadną z naszych zmiennych.
				</p>
				<img class="image" src="/variables-definition-example4.jpg" alt="Przedstawienie połączeń między zmiennymi na schemacie."/>
				<img class="image" src="/variables-definition-example5.jpg" alt="Zmiana przypisania zmiennej do wartości."/>
				<img class="image" src="/variables-definition-example6.jpg" alt="Przedstawienie zmiany połączenia zmiennej z wartością na schemacie."/>
			<p class="article__paragraph">
				Przenosząc ten przykład na obiekty, mamy dwie zmienne humanOne i humanTwo, które wskazują na obiekt, który ma takie własności jak name i age, wskazujące na konretne wartości. Różnica w stosunku do poprzedniego przykładu jest taka, że połączenia między własnościami i wartościami nie są stałe, można je zmieniać (na wcześniejszym przykładzie można było zmienić tylko przypisanie zmiennej zdefiniowanej za pomocą słowa kluczowego let). Własności nie mają takich sztywnych ram jak zmienne.
			</p>
			<img class="image" src="/object-variable-example1.jpg" alt="Definicja zmiennych i obiektów."/>
			<img class="image" src="/object-variable-example2.jpg" alt="Przedstawienie połączeń między zmiennymi, obiektami i wartościami za pomocą grafu."/>
			<img class="image" src="/object-variable-example3.jpg" alt="Zmiana własności age dla jednego z obiektów."/>
			<p class="article__paragraph">
				Po zmianie przypisania wartości dla własności age w obiekcie humanTwo, w console.log zostanie zwrócona nowoprzypisana wartość tej własności.
			</p>
			<img class="image" src="/object-variable-example4.jpg" alt="Widok wywołania obiektu ze zmienioną wartością własności age w zakładce console w devtools."/>
			<p class="article__paragraph">
				Jeśli zmienimy przypisanie w ten sposób, że obiekt humanTwo będzie wskazywał na obiekt humanOne, to powstaną dwa obiekty z własnościami o takich samych wartościach. Tak naprawdę nie będą to jednak dwa obiekty, nie powstanie kopia obiektu humanOne, tylko obie zmienne, humanOne i humanTwo będą wskazywały na ten sam obiekt.
			</p>
			<img class="image" src="/object-variable-example5.jpg" alt="Graf przedstawiający sytuację, gdzie zmienna humanTwo wskazuje na obiekt humanOne."/>
			<p class="article__paragraph">
				Jeśli następnie zmienimy wartość własności age dla zmiennej humanTwo, to zmieni się ona również dla humanOne, gdyż obie wskazują na ten sam obiekt. Możemy zatem zmieniać wartości własności jednej zmiennej za pomocą zmian w drugiej zmiennej, gdyż każda zmiana w jednej zmiennej, będzie miała zastosowanie również dla drugiej. Jeśli chcielibyśmy zrobić kopię obiektu, to robimy to w inny sposób, który zostanie opisany w kolejnych lekcjach.
			</p>
			<img class="image" src="/object-variable-example6.jpg" alt="Widok wywołania obiektu ze zmienioną wartością własności age w zakładce console w devtools w sytuacji, gdy zmienne humanOne i humanTwo wskazują na ten sam obiekt."/>
			<img class="image" src="/object-variable-example7.jpg" alt="Graf przedstawiający sytuację, gdzie zmienne humanTwo i humanOne wskazują na ten sam obiekt, dla którego zostaje zmieniona wartość własności age poprzez zmianę w zmiennej humanTwo."/>
			<p class="article__paragraph">
				Jeśli natomiast pod wiek zmiennej humanTwo podepniemy wiek ze zmiennej humanOne, to mamy dwa obiekty, gdzie w jednym z nich mamy wskazanie na własnoć zdefiniowaną w drugim. W takiej sytuacji nie dochodzi do połaczenia między obiektami, ale po prostu obie własności z obu obiektów wskazują na tę samą wartość (age 32).
			</p>
			<img class="image" src="/object-variable-example8.jpg" alt="Widok wywołania obiektów w zakładce console w devtools w sytuacji, gdy własność age ze zmiennej humanTwo odnosi się do wartości wasności age ze zmiennej humanOne."/>
			<img class="image" src="/object-variable-example9.jpg" alt="Graf przedstawiający sytuację, gdzie własność age ze zmiennej humanTwo odnosi się do wartości wasności age ze zmiennej humanOne."/>
			<p class="article__paragraph">
				Jeśli wartość age z hunamOne się zmieni, to nie dojdzie do automatycznej zmiany wartości własności age w humanTwo. W sytuacji, gdy wskazujemy na typy proste, następuje bowiem wskazanie bezpośrednio na wartość. Czyli kopiujemy połączenie między własnością age z humanOne i wartością 32. Zatem jeżeli zmienimy wiek dla humanOne, to wiek dla humanTwo nie ulegnie zmianie. Dzieje się tak, ponieważ, gdy tworzyliśmy ten obiekt dla zmiennej humanTwo, to wskazanie dla age było na wartość 32. Nie było to żadne specjalne wskazanie na humanOne, lecz po prostu skopiowanie wartości.
			</p>
			<img class="image" src="/object-variable-example10.jpg" alt="Widok wywołania obiektów w zakładce console w devtools w sytuacji, gdy własność age ze zmiennej humanTwo odnosi się do wartości własności age ze zmiennej humanOne, a następnie zmieniamy wartość age dla humanOne."/>
			<p class="article__paragraph">
				Korzystanie z zagnieżdżonych obiektów - do zmiennej humanOne dodajemy własność adres, na którą składa się ulica i miasto, które stanowią tak naprawdę nowy obiekt. Natomiast w zmiennej humanTwo, własność adres wskazuje na humanOne.address. W efekcie w zmiennej humanOne mamy taki sam adres, bo jest to ten sam obiekt. Jest to podobna sytuacja do tej, w której wskazywaliśmy, że humanTwo = humanOne.
			</p>
			<img class="image" src="/object-variable-example11.jpg" alt="Widok wywołania obiektów w zakładce console w devtools w sytuacji, gdy własność address ze zmiennej humanTwo odnosi się do własności address ze zmiennej humanOne, przy czym własność ta jest obiektem."/>
			<img class="image" src="/object-variable-example12.jpg" alt="Graf przedstawiający sytuację, gdzie własność address ze zmiennej humanTwo odnosi się do obiektu address ze zmiennej humanOne."/>
			<p class="article__paragraph">
				Jeśli zmienimy wartość własności street w obiekcie address zagnieżdżonym w obiekcie humanOne, to po wywołąniu zmiennych humanOne i humanTwo, w obu wartość własności street będzie zmieniona. Dzieje się tak, ponieważ odwołujemy się bezpośrednio do obiektu, który tę własność zawiera. Zmiana nastąpiła tylko w obiekcie address w zmiennej humanOne, który wskazuje teraz na inny typ prosty. W przypadku humanTwo nic sie nie zmieniło - wskazuje cały czas na ten sam obiekt. Jeśli zatem w naszym obiekcie wskazujemy na obiekt zagnieżdżony w innym obiekcie, to każda zmiana w tym zagnieżdżonym obiekcie będzie powodowała również zmianę w obiekcie, który się do niego odwołuje.
			</p>
			<img class="image" src="/object-variable-example13.jpg" alt="Widok wywołania obiektów w zakładce console w devtools w sytuacji, gdy własność address ze zmiennej humanTwo odnosi się do wartości własności address ze zmiennej humanOne, a następnie zmieniamy wartość własności street wchodzącej w skład obiektu address dla humanOne."/>
			<img class="image" src="/object-variable-example14.jpg" alt="Graf przedstawiający sytuację, gdy własność address ze zmiennej humanTwo odnosi się do wartości własności address ze zmiennej humanOne, a następnie zmieniamy wartość własności street wchodzącej w skład obiektu address dla humanOne."/>
			<p class="article__paragraph">
				Odmiennie będzie wyglądać sytuacja w przypadku, gdy do zmiennej humanTwo dodamy własność adres, ale z własnym obiektem, a nie ze wskazaniem na adres ze zmiennej humanOne, przy czym w obiekcie tym własność street będzie się odwoływała do wartości własności street ze zmiennej humanOne. Odwołujemy się tutaj do samej wartości danej własności, a nie całego obiektu, a zatem w przypadku późniejszej zmiany tej wartości dla zmiennej humanOne, w zmiennej humanTwo wartość ta się nie zmieni. Pozostanie taka sama, jaka została zdefiniowana w momencie utworzenia powiązania. Wskazanie było na typ prosty, a nie na obiekt, a zatem w momencie tworzenia powiązania w zmiennej humanTwo, została pobrana wartość, jaka istniała w momencie tworzenia obiektu humanOne. Późniejsza zmiana wartości w humanOne, nie będzie miała dla humanTwo zastosowania.
			</p>
			<img class="image" src="/object-variable-example15.jpg" alt="Widok wywołania obiektów w zakładce console w devtools w sytuacji, gdy własność street składająca się na obiekt address ze zmiennej humanTwo odnosi się do wartości własności street ze zmiennej humanOne, a następnie zmieniamy wartość własności street wchodzącej w skład obiektu address dla humanOne."/>
			<img class="image" src="/object-variable-example16.jpg" alt="Graf przedstawiający sytuację, gdy własność street składająca się na obiekt address ze zmiennej humanTwo odnosi się do wartości własności street ze zmiennej humanOne, a następnie zmieniamy wartość własności street wchodzącej w skład obiektu address dla humanOne."/>
			<p class="article__paragraph">
				Podsumowując, jeśli za pomocą własności lub zmiennej wskazujemy na jakiś obiekt, to wszystko, co jest do tego obiektu podłączone, będzie posiadało zaktualizowaną wartość własności składających się na ten obiekt. Jeśli natomiast własność wskazuje na typ prosty, to kopiujemy tylko połączenie do typu prostego i możemy je zmieniać bez konsekwencji dla innych zmiennych lub własności.
			</p>
			</article>
		</section>
		<section class="section">
			<h2 class="section__header">JavaScript - tydzień 6</h2>
			<article class="article">
				<h3 class="article__header">Logika w JS</h3>
				<p class="article__paragraph">
					Spora część programowania opiera się na logice, a logika jest często odpowiedzią na pytanie, czy wyrażenie, o które pytamy jest prawdziwe czy fałszywe i wykonaniem odpowiednich operacji zależnie od tej odpowiedzi. Pytanie o prawdę i fałsz, to tzw. porównanie. Aby zapisać porównanie za pomocą JavaScriptu można skorzystać z instrukcji if - jeśli wynik porównania jest prawdą, to należy wykonać kawałek kodu znajdujący się w nawiasach klamrowych, jeśli natomiast nie jest prawdą, to należy po prostu przejść dalej. Poniżej znajduje si przykład porównania w oparciu o operator porównnia !=, czyli nie równa się. Gdyby porównywane stringi były identyczne, czyli wartość porównania logicznego byłaby fałszem, to wówczas kod w nawiasie klamrowym by się nie wykonał.
				</p>
				<img class="image" src="/logic-if-instruction.jpg" alt="Przykład instrukcji if zawierającej porównanie dwóch stringów."/>
				<p class="article__paragraph">
					Poniżej znajduje się lista operatorów porównania wykorzystywanych w JavaScript. Operatory mniejszości/większości służą standardowo do porównywania liczb i działają tak samo jak w matematyce.
				</p>
				<img class="image" src="/comparison-operators.jpg" alt="Operatory porównania wykorzystywane w JavaScript."/>
				<p class="article__paragraph">
					Pojedynczy znak równości to operator przypisania, nie używamy go przy porównaniach. Żeby porównać dwie strony używamy podwójnego znaku równości. Można porównywać zarówno liczby, jak i inne wyrażenia. Natomiast 3 znaki równości sprawdzają również typeof, czyli jeśli porównamy cyfry 2 w formie liczby oraz cyfrę dwa w formie stringa uzyskamy fałsz. Jeśłi to samo porównanie wykonamy wykorzystując 2 znaki równości, to wynikiem będzie prawda. Operator porównania skłądający się z 3 znaków równości najpierw sprawdza typy, jeśli są różne, to zwraca fałsz i nie weryfikuje już wartości. Jeśli chcemy porównać po prostu ilość sztuk, to zwykły podwójny znak równości będzie ok, ale jeśli porównujemy np. wartości w dwóch walutach (np. 2 eur i 2 pln), to zasadne będzie porównanie za pomocą potrójnego znaku równości, weryfikującego również typeof. Bezpieczniejsze i bardziej przewidywalne jest porównywanie za pomocą 3 znaków, dzięki czemu mamy pewność, że to jest ten sam typ.
				</p>
				<img class="image" src="/logic-operator-example1.jpg" alt="Przykład porównania dwóch wartości za pomocą operatora potrójnego znaku równości."/>
				<p class="article__paragraph">
					Analogicznie działa porównanie z zaprzeczeniem, czyli sprawdzanie, czy obie strony są różne. Jeśli użyjemy operatora z podwójnym znakiem równości !==, to nawet jeśli będziemy mieli te same wartości, ale mające odmienne type of (number i string), to uzyskamy wartość prawda, jako, że strony równania nie są takie same.
				</p>
				<img class="image" src="/logic-operator-example2.jpg" alt="Przykład porównania z zaprzeczeniem dwóch wartości o odmiennym typeof za pomocą operatora z podwójnym znakiem równości."/>
				<p class="article__paragraph">
					Korzystając z instrukcji if, możemy również używać tzw. falsy, czyli fałszywych wartości, które zwracają false w JavaScript. Takich wartości jest 6. 
				</p>
				<img class="image" src="/falsy-examples.jpg" alt="Wartości falsy w JavaScript."/>
				<p class="article__paragraph">
					Pierwsza to po prostu false. Druga to 0, które zwróci zawsze wartość fałszywą. Kolejna to pusty string, niezawierający żadnego znaku. Następnie null, undefined i NaN, czyli not a number, który jest zwracany, gdy próbujemy wykonać operację z czymś, co nie jest liczbą. Poniżej przykład takiej operacji, gdzie strong mnożymy razy 6 i uzyskujemy Nan, czyli w efekcie false (kod nie jest wykonywany).
				</p>
				<img class="image" src="/falsy-nan.jpg" alt="Przykład kodu, w którym jako rezultat uzyskujemy not a number."/>
				<p class="article__paragraph">
					JavaScript działa tutaj w sposób szczególny, bo w sytuacji, gdy zamiast mnożyć jakiegoś stringa, dodamy do niego jakąś liczbę, to uzyskamy prawdę.
				</p>
				<img class="image" src="/truthy-example.jpg" alt="Przykład kodu z użyciem wartości truthy, w którym jako rezultat uzyskujemy prawdę."/>
				<p class="article__paragraph">
					Dzieje się tak, ponieważ wszystkie wartości poza wyżej wymienionymi, to tzw. truthy, czyli wartości, dla których zwraca nam prawdę. Są to między innymi stringi, czyli tekst, liczby dodatnie i ujemne, z wyjątkiem 0, pusty obiekt, czy nawiasy klamrowe bez zawartości, tablica, którą zapisujemy jako nawiasy kwadratowe oraz wyrażenie true jako sama wartość, a nie wynik jakiegoś wyrażenia.
				</p>
				<img class="image" src="/truthy-example1.jpg" alt="Lista przykładowych wartości truthy."/>
				<p class="article__paragraph">
					Nasze wyrażenia logiczne możemy ze sobą łączyć, co robimy za pomocą logicznego "i" zapisywanego jako dwa znaki ampersand (&&). Aby wyrażenie logiczne skłądające sie z wyrażeń połączonych ze sobą za pomocą AND było prawdziwe, to każde z nich musi być prawdą. Jeśli choć jedno będzie fałszywe, to całe wyrażenie główne również zwróci fałsz.
				</p>
				<img class="image" src="/logic-and.jpg" alt="Łączenie wyrażeń logicznych za pomocą AND."/>
				<img class="image" src="/operator-and-example.jpg" alt="Przykład użycia operatora AND w kodzie."/>
				<p class="article__paragraph">
					Drugim operatorem, za pomocą którego możemy łączyć nasze wyrażenia logiczne jest OR, czyli "lub" zapisywany w formie dwóch pionowych kresek (||). W tym przypadku wystarczy, że jedno wyrażenie, wchodzące w skłąd wyrażenia głównego, jest prawdziwe i wówczas całe wyrażenie główne jest prawdziwe.
				</p>
				<img class="image" src="/logic-or.jpg" alt="Łączenie wyrażeń logicznych za pomocą OR."/>
				<p class="article__paragraph">
					Kolejnym operatorem logicznym jest NOT zapisywany w formie pojedynczego wykrzyknika (!), który odwraca wartość naszego wyrażenia logicznego. Dodajemy go na początku wyrażenia, którego wartość chcemy odwrócić. W efekcie !false zwróci nam prawdę, a !true da wynik fałszywy.
				</p>
				<img class="image" src="/logic-not.jpg" alt="Wykorzystanie w wyrażeniu logicznym operatora NOT."/>
				<p class="article__paragraph">
					Jeśli chcemy rozbudować nasz warunek i stworzyć dodatkowe warunki, możemy wykorzystać instrukcję ELSE, której kod zostanie wykonany w sytuacji, gdy sprawdzane wyrażenie będzie fałszywe.
				</p>
				<img class="image" src="/logic-else.jpg" alt="Sposób wykorzystania instrukcji ELSE."/>
				<img class="image" src="/else-example.jpg" alt="Przykład kodu z wykorzystaniem instrukcji ELSE."/>
				<p class="article__paragraph">
					Poniżej znajduje się przykład wykorzystania instrukcji ELSE w przypadku zmiennej, której nadajemy na początku wartość false, a następnie zmieniamy na true (na przepięcie pozwala nam zdefiniowanie zmiennej za pomocą LET). Kod wykoywany jest z góry na dół, a zatem najpierw wykona się kod znajdujący się po instrukcji ELSE, a następnie ten po instrukcji IF.
				</p>
				<img class="image" src="/else-example1.jpg" alt="Przykład kodu z wykorzystaniem instrukcji ELSE oraz zmiennych o wartości true i false."/>
				<p class="article__paragraph">
					Instrukcja ELSE IF bardzo dokładnie specyfikuje to, co ma zostać sprawdzone. Nie zostanie wykonana zawsze, a jedynie w określonej sytuacji. Jeśli pierwszy z napotkanych if/else if, okaże się prawdą, to kolejne nie są już sprawdzane, nawet jeśli okazałyby się również prawdą.
				</p>
				<img class="image" src="/logic-elseif.jpg" alt="Sposób wykorzystania instrukcji ELSE IF."/>
				<p class="article__paragraph">
					Możemy zatem rozbudowywać nasze wyrażenie o kolejne warunki, korzystając z instrukcji ELSE IF i na koniec obsłużyć wszystkie pozostałe przypadki, które nie zostały uwzględnione w tych warunkach, za pomocą instrukcji ELSE.
				</p>
				<img class="image" src="/elseif-example.jpg" alt="Przykład wykorzystania instrukcji ELSE IF oraz ELSE."/>
				<p class="article__paragraph">
					Do porównań, które odwołują się typowo do wartości, czyli sprawdzają za pomocą operatora, że jest równe, wykorzystywana jest instrukcja SWITCH, która przyjmuje jako parametr albo zmienną albo jakąś wartość, i za pomocą instrukcji CASE wykonuje odpowiedni kod, jeśli dana zmienna wskazuje na wartość z danego CASE, a następnie za pomocą instrukcji BREAK wychodzi z głównego bloku kodu.
				</p>
				<img class="image" src="/logic-switch.jpg" alt="Sposób wykorzystania instrukcji SWITCH."/>
				<p class="article__paragraph">
					Składnia instrukcji SWITCH jest trochę inna niż w poznanych do tej pory - dwukropek przy CASE, a następnie średnik z BREAK stanowią odpowienik klamr, które stosowaliśmy dotychczas do otwarcia i zamknięcia. Zatem poszczególne warunki CASE są odpowiednikiem ELSE IF, a DEFAULT pełni taką rolę jak ELSE we wcześniejszym przykładzie. W przypadku DEFAULT nie dodajemy już żadnego BREAK na końcu, bo jest to domyślna ostania odpowiedź.
				</p>
				<img class="image" src="/switch-example.jpg" alt="Przykład wykorzystania instrukcji SWITCH."/>
				<p class="article__paragraph">
					Istnieje również zapis skrócony instrukcji IF przy użyciu znaku zapytania i dwukropka (tzw. ternary/conditional operator). Ternary, czyli potrójny, składa się on bowiem z trzech części, pierwsza to nasze porównanie, coś, co chcemy sprawdzić, po którym dajemy znak zapytania; druga to kod, który ma się wykonać w sytuacji, gdy porównanie da wynik prawda, po którym dajemy dwukropek, i trzecia część, czyli kod, który ma się wykonać, gdy uzyskamy wynik false.
				</p>
				<img class="image" src="/short-if.jpg" alt="Skrócony zapis instrukcji IF."/>
				<p class="article__paragraph">
					Na stronie Mozilli operator ten został opisany tak:
				</p>
				<p class="article__paragraph">
					The conditional (ternary) operator is the only JavaScript operator that takes three operands: a condition followed by a question mark (?), then an expression to execute if the condition is truthy followed by a colon (:), and finally the expression to execute if the condition is falsy. This operator is frequently used as an alternative to an if...else statement.
				</p>
				<img class="image" src="/ternary-operator.jpg" alt="Przykład użycia potrójnego operatora."/>
				<p class="article__paragraph">
					W przypadku tego potrójnego operatora nie chcemy wrzucać dużych bloków kodu, są to dosłownie jednolinijkowe porównania na szybko, które są często wykorzystywane np. w pracy z blibioteką REACT.
				</p>
				<p class="article__paragraph">
				Maciek podał namiary na prezentację WAT, która opisuje dziwne rzeczy związane z JavaScriptem i to, jak ten jezyk zachowuje się w pewnych przypadkach, gdy dodajemy do siebie różne rzeczy i jakie wartości wówczas zwraca, mimo, że nie jest to logiczne: <a class="article__link" href="https://www.destroyallsoftware.com/talks/wat">prezentacja WAT o dziwnych zachowania w JavaScript</a>.
			</p>
			</article>
			<article class="article">
				<h3 class="article__header article__header--js">Eventy w JS</h3>
				<button class="article__button article__button--js">Zmień treść nagłówka</button>
				<p class="article__paragraph">
					Przepis na przycisk zmieniający nagłówek, to utworzenie przycisku i nagłówka oraz napisanie kodu JS, który obsłuży klinięcie oraz kodu, który zmieni treść nagłówka.
				</p>
				<p class="article__paragraph">
					&lt;button&gt; to tag HTML, który służy do interakcji z użytkownikiem. Treść buttonu jest opisem akcji, która się wykona, gdy użytkownik w niego kliknie. Do nagłówka, którego treść będziemy zmieniać oraz do przycisku, dodajmy klasę, która będzie służyła do odnoszenia się do niej za pomocą JS.
				</p>
				<p class="article__paragraph">
					Zasadnicza różnica między tagiem &lt;button&gt; a tagiem &lt;a&gt; jest taka, że ten pierwszy służy do interakcji na stronie, a drugi do nawigacji.
				</p>
				<p class="article__paragraph">
					Po utworzeniu przycisku, piszemy skrypt, który będzie nasługiwał na to kliknięcie, które ma zmienić treść nagłówka. Korzystamy w tym celu z poniższej metody.
				</p>
				<img class="image" src="/event-listener.jpg" alt="Metoda nasłuchująca wystąpienie eventów."/>
				<p class="article__paragraph">
					W metodzie służącej do nasłuchiwania, podajemy typ eventu, na który chcemy nasłuchiwać (w naszym przypadku kliknięcie, a zatem click) oraz listener, czyli funkcję, która będzie się wykonywać, gdy ten event wystąpi. Podajemy tylko nazwę funkcji jako parametr, bez żadnych nawiasów, listener będzie już wiedział, do której funkcji się odwołać i ją wykonać. Metodę tę możemy podpiąć pod dowolny element (może być to body, button, etc.).
				</p>
				<p class="article__paragraph">
					Są rozmaite rodzaje eventów, które mogą wystąpić, my jednak skupimy się w tej chwili na eventach generowanych za pomocą myszki, a konkretnie na click. Pełną listę eventów myszkowych można znaleźć na stronie Mozilli: <a class="article__link" href="https://developer.mozilla.org/en-US/docs/Web/API/Element#mouse_events">lista mouse events</a>.
				</p>
				<p class="article__paragraph">
					W tej chwili zostało to już ujednolicone i event click wykonany za pomocą myszki jest tożsamy z dotknięciem palcem na urządzeniu mobilnym. Są jednak eventy ściśle związane z myszką, kursorem i monitorem, takie jak mouseenter, mouseleave czy mouseover, które na urządzeniach mobilnych już nie zadziałają.
				</p>
				<img class="image" src="/event-listener-function.jpg" alt="Metoda nasłuchująca wystąpienie eventu click i wywołująca określoną funkcję."/>
				<p class="article__paragraph">
					W pliku ze skryptami JS za pomocą querySelectora pobieramy nagłówek i przycisk, odwołując się do nich za pomocą dodanej klasy do obsługi skryptów JS. Możemy od razu dodać console.log, by sprawdzić, czy pobierają nam się właściwe elementy. Następnie dodajemy eventListenera, który będzie nasłuchiwać na naszym przycisku - robimy to tylko raz, on będzie działać oczywiście za każdym razem. Poniżej przykład wywołania funkcji dodającej wpisy o kliknięciu w konsoli w devtools - za każdym kliknięciem licznik jej wywołania jest odpowiednio zwiększany.
				</p>
				<img class="image" src="/click-function.jpg" alt="Wywołanie funkcji nasłuchującej wystąpienie eventu click i dodającej wpis w konsoli w devtools."/>
				<p class="article__paragraph">
					Możemy zdefiniować naszą funkcję z parametrem (e), który odnosi się do eventu i po jej wywołaniu w console.log za pomocą eventListenera, będziemy mieć pełne informacje na temat tego eventu w PointerEvent - w przypadku klinięcia będzie to między innymi położenie kursora, target, który został kliknięty (możemy się do niego odnieść poprzez e.target), etc. Pełna dokumentacja na temat eventów znajduje się na stronie Mozilli: <a class="article__link" href="https://developer.mozilla.org/en-US/docs/Web/API/event">szczegółówe informacje na temat eventów</a>.
				</p>
				<img class="image" src="/pointer-event.jpg" alt="Wywołanie funkcji nasłuchującej wystąpienie eventu click z parametrem e."/>
				<p class="article__paragraph">
					Mamy już nagłówek, przycisk i kod obsługujący kliknięcie, potrzebujemy jeszcze kodu zmieniającego treść nagłówka. Możemy w tym celu go pobrać już w ciele funkcji za pomocą querySelector. Następnie wykorzystując własność innerHTML dodajemy treść wybranego elementu HTML, jaka ma zostać wyświetlona po klinięciu w przycisk.
				</p>
				<img class="image" src="/change-on-click.jpg" alt="Wywołanie funkcji zmieniajcej treść nagłówka po kliknięciu w przycisk."/>
				<p class="article__paragraph">
					Kolejne kliknięcia w przycisk również wywołuja funkcję i zmieniają tytuł nagłówka, ale nie widzimy tego na stronie, gdy zmiana następuje z już zmienionego tutułu. Po odświeżeniu strony, wszystko wraca do normy, bo oczywiście w samym kodzie źródłowym HTML nie nastąpiły żadne zmiany, interakcje zachodzą jedynie w DOM.
				</p>
				<p class="article__paragraph">
					Jeśli kod, który ma się wykonać jest dość krótki, tak jak w naszym przypadku i jest wykorzystywany tylko w jednym miejscu (u nas tylko na tym kliknięciu), to nie musimy podawać nazwy funkcji w eventListenerze, możemy samą funkcję wrzucić bezpośrednio do eventListenera po podaniu typu eventu i przecinku.
				</p>
				<img class="image" src="/function-in-listener.jpg" alt="Definicja funkcji zmieniajcej treść nagłówka po kliknięciu w przycisk, znajdująca się bezpośrednio w eventListenerze."/>
			</article>
		</section>
	</div>
	</main>
    <footer class="footer">
		<p class="footer__content">Strona domowa Magdaleny Derek, wszystkie treści są wynikiem nauki w ramach szkolenia WTF: Co
			ten frontend. 
			<a class="footer__top-link" href="#top">Wróć na górę strony ⬆️</a>
		</p>
		</footer>
	<script defer src="/main.js"></script>
</body>

</html>