<!DOCTYPE html>
<html lang="pl">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Notatki z frontendu</title>
	<link href="/normalize.css" rel="stylesheet" type="text/css">
	<link href="/style.css" rel="stylesheet" type="text/css">
</head>

<body class="body">
	<header class="header">
		<nav class="navigation">
			<a class="navigation__link" href="/index.html">Strona główna</a>
			<a class="navigation__link" href="/nauka-html.html">Nauka HTML</a>
			<a class="navigation__link" href="/nauka-css.html">Nauka CSS</a>
			<a class="navigation__link" href="/nauka-js.html">Nauka JavaScriptu</a>
			<a class="navigation__link" href="/nauka-varia.html">Nauka - varia</a>
		</nav>

	</header>
	<main class="main">
		<header>
			<h1 id="top" class="main__header">Nauka JavaScriptu</h1>

		</header>
		<section class="section">
			<h2 class="section__header">JavaScript - tydzień 2 i 3</h2>
			<article class="article">
				<h3 class="article__header">Podstawy</h3>
				<p class="article__paragraph">
					JAVA SCRIPT – umożliwia interakcje
				</p>
				<p class="article__paragraph">
					ECMAScript - skryptowy język oprogramowania, ustandaryzowany przez organizację ECMA, ECMAScript
					Language Specification.<br>
					ECMA - European Association for Standardizing Information and Communication Systems jest to
					organizacja, której zadaniem jest tworzenie standardów technologicznych.<br>
					Co roku jest aktualizowany, w kursie wykorzystywany ES6+ dla roku 2015+ i nowszych, do 2020
					włącznie. JavaScript implementuje rzeczy ze specyfikacji ECMAScript.
					Nowo wprowadzone feature'y, funkcje języka, mogą nie być wspierane we wszystkich przeglądarkach, które też muszą wprowadzać nowe wersje, żeby gonić standardy, ale
					można to obejść.
				</p>
				<p class="article__paragraph">
					JavaScript jest obiektowym językiem programowania i składa się z następujących elementów:<br>
					- wartości,<br>
					- zmienne,<br>
					- funkcje,<br>
					- literały,<br>
					- obiekty,<br>
					- operacje porównywania.
				</p>
				<p class="article__paragraph">
					Wartości są dla JS tym, czym liczby dla matematyki - jest to pewien zbiór, który już istnieje, nie
					tworzymy go.
					Wartością może być np. jakaś liczba, słowo. Są one niezmienialne.
				</p>
				<p class="article__paragraph">
					Pliki zawierające kod JavaScript mają rozszerzenie .js. Podobnie jak style mają też swój znacznik
					"script".<br>
					Znacznik "script" dodajemy na samym dole strony, po stopce "footer", tuż przed domknięciem znacznika
					"body".<br>
					Przykładem może być funkcja alert, która składa się z nazwy funkcji, nawiasów otwartych oraz
					znajdujących się w nawiasie parametrów w pojedynczych apostrofach (zamiast pojedynczych apostrofów, można dać podwójne - cudzysłów, to też zadziała). Na końcu dajemy średnik ;
					oznaczający zakończenie linii.<br>

				</p>
				<img class="image" src="//tag-script.JPG"
					alt="Przedstawienie umiejscowienia znacznika script z funkcją alert przed domknięciem znacznika body." />
				<p class="article__paragraph">
					Skrypt wykonuje się tylko raz, jeszcze przed załadowaniem strony. W przypadku funkcji alert jest to
					wyskakujące okienko zawierające treść podaną w parametrach funkcji.
				</p>
				<img class="image" src="//alert-example.JPG"
					alt="Przykład działania funkcji alert na stronie - wyskakujące okienko." />
				<p class="article__paragraph">
					Tak, jak w przypadku stylów, bezpośrednie pisanie kodu JavaScript w pliku z htmlem zadziała, ale
					jest mało praktyczne, dlatego stosuje się wydzielanie kodu JavaScript do osobnego pliku, np.
					main.js.<br>
					W pliku zawieramy po prostu bezpośrednio treść naszego kodu JavaScript w kolejności, w jakiej ma być
					wykonywany.<br>
					Odniesienie do pliku z kodem JavaScript umieszczamy na końcu strony, przed domknięciem znacznika
					body, używając znacznika "script".
					Używamy atrybutu "src", tak jak w obrazkach, a nie "href", tak jak w przypadku stylów.
				</p>
				<img class="image" src="//main-file.JPG" alt="Odwołanie do pliku z kodem JavaScript w pliku HTML." />
				<p class="article__paragraph">
					Kolejnym poleceniem jest funkcja console.log, która w przeciwieństwie do funkcji alert nie wyświetla
					informacji na stronie, ale w narzędziach deweloperskich w zakładce "console".<br>
					Funkcja console.log pozwala na wyświetlenie określonego tekstu lub wartości, np.:<br>
					console.log('tekst');<br>
					Jeśli wpisze się funkcję dwa razy, to zostanie ona wywołana dwukrotnie.
				</p>
				<img class="image" src="//consolelog-example1.JPG"
					alt="Przykład dwukrotnego wywołania funkcji console.log w konsoli w narzędziach deweloperskich w przeglądarce." />
				<p class="article__paragraph">
					Zmienna w JavaScript to stworzenie powiązania między nazwą, której chcemy użyć a wartością, którą chcemy
					przypisać tej zmiennej.<br>
					const name = 'Magdusia';<br>
					const age = 38;<br>
					Zmiennej o nazwie "name" przypisujemy wartość słowną "Magdusia", używając apostrofów. Zmiennej o nazwie "age"
					przypisujemy wartość liczbową "38", nie używając apostrofów.<br>
					Przy tworzeniu zmiennych nie trzeba dawać średnika na końcu linii, przeglądarka to przetworzy. Jednak dla
					dobrej praktyki lepiej to robić, żeby zaznaczyć w ten sposób koniec linii.<br>
					Wywołując nazwę zmiennej w funkcji nie używamy apostrofów.<br>
					<img class="image" src="//consolelog-example2.JPG"
						alt="Stworzenie zmiennej słownej i liczbowej oraz ich wywołanie w funkcji console.log." />

				</p>
				<p class="article__paragraph">
					Backtick/backquote (`) - przetrącony apostrof, na klawiaturze znajduje się tam, gdzie tylda ~.<br>
					Używamy go, jeśli chcemy wykorzystać w jakiejś funkcji jednocześnie zmienną i tekst - taki ciąg znaków
					nazywamy <b>literałem</b>.<br>
					console.log(`Nazywam się ${firstName} i mam ${age} lat.`);
				</p>
				<img class="image" src="//consolelog-example3.JPG"
					alt="Wykorzystanie w funkcji console.log jednocześnie zmiennej oraz tekstu, czyli literału." />
				<p class="article__paragraph">
					Kod JS uruchamia się raz (po załadowaniu strony). Może też oczywiście działać później, jeśli ma odpowiednie
					instrukcje.
				</p>
			</article>
		</section>
		<section class="section">
			<h2 class="section__header">JavaScript - tydzień 4</h2>
			<article class="article">
				<h3 class="article__header">Typy i struktury danych, immutability</h3>
				<p class="article__paragraph">
					Zmienne w Java Script możemy zadeklarować (stworzyć) za pomocą trzech słów kluczowych: LET, CONST i VAR, omówionych poniżej.
				</p>
				<p class="article__paragraph">
					<h4 class="paragraph-header">LET</h4>				
					LET - zmienne, które definiujemy tylko raz, ale których połączenie możemy przepinać, w wyniku czego można zmieniać przypisaną danej zmiennej wartość tak, jak w przykłądzie poniżej. Po utworzeniu zmiennej za pomocą słowa kluczowego LET, możemy później za pomocą tej zmiennej wskazywać na inne wartości, zmieniać je.<br>
					let isHappy = false;<br>
					isHappy = true;<br>
					isHappy = 'tak';<br>
					<img class="image" src="//let-variable.jpg" alt="Przykład definiowania zmiennej za pomocą słowa kluczowego let."/>
				</p>
				<p class="article__paragraph">
					<h4 class="paragraph-header">CONST</h4>	
					CONST - tworzy zmienne, które mają stałe połączenie z jedną wartością, tak jak w definicjach poniżej. Jeśli będziemy próbowali przypisać do zmiennej age lub name jakąś inną wartość (np. age = 25), to otrzymmay błąd.<br>
					const name = 'Magdalena';<br>
					const age = 39;<br>
					<img class="image" src="//constant-variable.jpg" alt="Przykłady definiowania zmiennych za pomocą słowa kluczowego const."/>
				</p>
				<p class="article__paragraph">
					<h4 class="paragraph-header">VAR</h4>	
					VAR - obecnie definiowanie zmiennych za pomocą tego słowa kluczowego wychodzi z użycia.
				</p>
				<p class="article__paragraph">
					<h4 class="paragraph-header">Definiowanie zmiennych - przykłady</h4>	
					Poniżej znajdują sie dwa przykłady definiowania zmiennych. W pierwszym definiujemy zmienną x za pomocą CONST, przypisując jej wartość 10. Następnie definiujemy zmienną y za pomocą LET, przypisując jej wartość x. Po wykonaniu tego kodu, obie zmienne, x i y będą równe 10. Gdy zmiennej y przypiszemy następnie inną wartość, 20, to po wykonaniu kodu, zmienna y będzie miała wartość 20, ale zmienna x nadal będzie miałą wartość 10.<br>
					W drugim przykładzie odwracamy sytuację i definiujemy zmienną a za pomocą LET, przypisując jej wartość 20, a następnie definiujemy zmienną b za pomocą CONST, przypisując jej wartość a. Po wykonaniu kodu, obie zmienne będą miały wartość 20. Jeśli następnie zmiennej a przypiszemy inną wartość, 13, to po wykonaniu kodu, zmienna a będzie miała wartość 13, ale zmienna b nadal będzie miała wartość 10.<br>
					Dzieje się tak, ponieważ kod wykonuje się tylko raz. Wartość do zmiennej x w przykładzie pierwszym i zmiennej b w przykładzie drugim przypisujemy tylko w momencie pierwszego wykonania kodu. Wartość jest do nich przypisywana w momencie definiowania tych zmiennych. To, że następnie wartości zmiennych y i a ulegają zmianie, z punktu widzenia zmiennych x i b nie ma znaczenia. Powiązanie zostało bowiem wykonane wcześniej, gdy miały one inne wartości. W przykładach tych nie dokonujemy powiązania między zmiennymi ani między wartościami. Przypisujemy jedynie wskazanie na wartość, jaką wskazywała dana zmienna w momencie jej tworzenia.<br>
					<img class="image" src="//variables-definition-example1.jpg" alt="Przykład pierwszy definiowania zmiennych za pomocą const i let."/><br>
					<img class="image" src="//variables-definition-example2.jpg" alt="Przykład drugi definiowania zmiennych za pomocą const i let."/><br>
				</p>
				<p class="article__paragraph">
					<h4 class="paragraph-header">Typy proste w JS</h4>	
					Java Script jest językiem nietypowanym, co oznacza, że jako wartość zmiennej można podpiąć absolutnie wszystko. Typy w innych językach oprogramowania określają, jaki rodzaj wartości można podpiąć do zmiennej. Jednak pomimo tego, że jest to język nietypowany, Java Script posiada typy proste (primitives), czyli rodzaje wartości, które obejmują:<br>
					- string - tekst, który otaczamy za pomocą podwójnego apostrofu ", pojedynczego apostrofu ' lub kopniętego apostrofu ` (do zwykłych tekstów, w których nie używamy dodatkowych zmiennych, Maciek zaleca korzystanie z pojedynczych apostrofów);<br>
					- number - liczba;<br>
					- bigint - duża liczba, większa niż 2 do potęgi 53;<br>
					- boolean - true lub false, prawda lub fałsz, typ ten jest wykorzystywany do tworzenia logiki w JS, sprawdzania warunków etc.;<br>
					- null - wartość celowo niezdefiniowana, wiemy, że powinna być jakaś wartość, ale jej nie ma i celowo oznaczamy, że jej nie ma, ale sama zmienna jest zdefiniowana; wartość zapisujemy bez żadnych apostrofów, gdyż nie jest to wartość jako taka, ale typ wartości;<br>
					- undefined - brak definicji, dana zmienna nie została w ogóle zadeklarowana;
					- symbol - typ wartości wykorzystywany do tworzenia "unikalnych opakowań", raczej nie jest wykorzystywany, wymieniony został bardziej jako ciekawostka.<br> 
					<img class="image" src="//primitives-in-js.jpg" alt="Lista typów prostych w Java Script."/>
				</p>
				<p class="article__paragraph">
					<h4 class="paragraph-header">Instrukcja typeof</h4>	
					To, jaki typ ma dana zmienna możemy sprawdzić za pomocą instrukcji typeof. Instrukcja ta nie zawsze zwraca poprawny typ, którego się spodziewamy w danym przypadku. Na przykładzie podanym poniżej, przy sprawdzaniu typu zmiennej, do której została przypisana wartość null, typeof zwraca object zamiast null. Dzieje się tak dlatego, że w Java Script, jako języku obiektowym, wszystko jest obiektem, a null jest wskazaniem na pusty obiekt, w którym w przyszłości ma się znaleźć jakaś inna wartość.<br>
					<img class="image" src="//typeof-instruction-examples.jpg" alt="Przykłady sprawdzania typu zmiennych za pomocą instrukcji typeof."/>
				</p>
				<p class="article__paragraph">
					<h4 class="paragraph-header">Immutability</h4>	
					Immutability, czyli niemutowalność, jest to jeden z fundamentalnych konceptów Java Script. Oznacza, że nie można zmieniać wartości primitive values w Java Script. To, co zmieniamy, to połączenie między tymi wartościami a zmiennymi. Sam wszechświat wartości jest niezmienny. Nasze zmienne nie mogą ich modyfikować i sprawić, że np. 20 to będzie 13.
				</p>
			</article>
			<article class="article">
				<h3 class="article__header">DOM - document object model</h3>
				<p class="article__paragraph">
					DOM (obiektowy model dokumentu) to jest to, co widzimy w devtools w zakładce Elements. Nie jest to plik z kodem HTML w edytorze ani jako źródło naszej strony. DOM w devtools ma się tak do pliku z kodem HTML jak gotowy skręcony mebel do instrukcji jak go skręcić. Kod HTML jest to zatem instrukcja, która jest następnie interpretowana przez przeglądarkę i wyświetlana w postaci DOM. DOM jest zatem "złożonym" w przeglądarce kodem HTML. 
				</p>
				<p class="article__paragraph">
					DOM stanowi pomost pomiędzy kodem HTML a JavaScriptem. DOM może być bowiem przez JavaScript modyfikowany. Powstał po to, by można było modyfikować strony internetowe, operować na nich za pomocą JavaScriptu, by odnosząc się do nich dodać np. interakcje. Podobnie jak w CSS, żeby odnieść się do danego elementu używamy selektorów w postaci klas czy id, tak w przypadku JavaScriptu funkcję tę pełnią query selektory. Query selector jako parametr wykorzystuje te same selektory wskazujące na dany element, które stosowane są w CSS. Za pomocą querySelector wybieramy zatem węzły w HTML, by móc na nich operować (w naszym przykładzie modyfikacje nagłówka h1). Funkcja querySelector zwraca zatem node (węzeł) z HTML-a.
				</p>
				<img class="image" src="/query-selector.jpg" alt="Funkcja wykorzystująca query selectory."/><br>
				<p class="article__paragraph">
					Odpowiednikiem powyższego zapisu funkcji w jQuery, który obecnie stanowi już raczej ciekawostkę i element legacy, jest zapis z użyciem dolara: $('.selector').
				</p>
				<p class="article__paragraph">
					Do oznaczania elementów za pomocą specjalnej klasy, która będzie się odnosiła tylko do JavaScriptu wykorzystywana jest właśnie konwencja nazewnicza BEM: block__element--js.
				</p>
				<p class="article__paragraph">
					Aby wywołać sobie za pomocą funkcji console.log jakiś element na stronie możemy wykorzystać do tego jakąś zmienną, np. const header, wyszukując ją na stronie za pomocą querySelector. Przy ładowaniu z serwera, przeglądarka może czasem nie zdążyć zaczytać odpowiednio naszego DOM i pliku z kodem JavaScript i wówczas w devtools w Console przy wywołaniu danej funkcji, zamiast wyświetlenia wywołanego za pomocą funkcji elementu, pojawia się węzeł z pulą możliwych funkcji do wykorzystania na naszym elemencie. Można tam podejrzeć również tekst, kod html czy style naszego elementu, czyli cały pojedynczy węzeł naszego DOM, który widzi nasza przeglądrka (na naszym przykładzie jest to element h1). Nie wpływa to jednak na funkcjonalność strony, bo sam skrypt wykona nam się poprawnie, jest to tylko kwestia wizualnej reprezentacji tego obiektu. 
				</p>
				<img class="image" src="/node.jpg" alt="Węzeł z pulą dostępnych funkcji w zakładce Console w devtools."/>
				<p class="article__paragraph">
					Aby jednak zniwelować szansę na wystąpienie takiej sytuacji i zapewnić, by skrypty wczytywały nam się w odpowiednej kolejności, do linku z odniesieniem do naszego pliku JS w kodzie HTML należy dodać atrybut defer (wpisujemy go po znaczniku script, przed adresem src). Wówczas po wywołaniu funkcji w zakładce Console powinien nam się wyświetlić dany element w takiej samej postaci, w jakiej jest widoczny w zakładce Elements w DOM.
				</p>
				<img class="image" src="/query-selector-example.jpg" alt="Funkcja wywołująca element h1 na naszej stronie za pomocą query selector."/>
				<p class="article__paragraph">
					Jak już zostało wcześniej wspomniane, w celu ułatwienia identyfikacji, do oznaczenia naszego elementu można wykorzystać BEM i dodatkową klasę z modyfikatorem --js. Selektorów takich nie wykorzystujemy do stylowania w CSS. Używamy ich jedynie w JavaScript, dzięki czemu nasze skrypty będą nadal działać nawet wówczas, gdy zdecydujemy się na zmianę stylów CSS czy przeniesienie elementu.
				</p>
				<p class="article__paragraph">
					JavaScript, jako nawyższa wartstwa na naszej stronie, może zmieniać na niej wszystko. Możemy więc zmienić np. treść naszego elementu h1. Mamy już wybrany nasz element za pomocą querySelectora i możemy teraz wykonywać na nim operacje. Możemy w tym celu wykorzystać własność innerHTML, która odpowiada za treść naszego elementu, czyli to co, jaki html znajduje się w środku tego elementu: nazwaZmiennejQuerySelector.innerHTML = 'treść'.
				</p>
				<p class="article__paragraph">
					Działając na naszym przykładzie nagłówka h1 i wywołując w console.log naszą funkcję header, w konsoli wyświetla nam się cały nasz obiekt, który po najechaniu zostaje również podświetlony na stronie w oknie przeglądarki. Jeśłi jednak wywołamy sobie header.innerHTML, to w konsoli wyświetli nam się tylko zawartość elementu, jego treść, odnosimy się bowiem do samej wartości. Możemy również tę treść zmienić, podając nową: header.innerHTML = 'Hej'. Jest to przykład, gdy w pliku HTML i w źródle strony będziemy mieć wcześniejszą wartość, natomiast w DOM wyświetli się już nowa treść nagłówka, podmieniona za pomocą JavaScriptu. Czyli przykład różnicy między instrukcją a złożonym meblem. Jako nową treść możemy również podstawić utworzone wcześniej zmienne name i age: header.innerHTML = `Witaj, nazywam się ${firstName} i mam ${age} lat.` Przy tworzeniu stron statycznych nie robimy takich rzeczy, nie wrzucamy treści statycznej za pomocą skryptów, ale już przy korzystaniu z danych zewnętrznych alo danych przeliczanych przez JavaScript będziemy w ten sposób podmieniać dane (np. zmiana licznika, gdy użytkownik kliknie na plus).
				</p>
				<img class="image" src="/inner-html.jpg" alt="Wykonanie skryptu zmieniającego treść nagłówka."/>
				<p class="article__paragraph">
					Za pomocą skryptów JS możemy również modyfikować style. Jeśli wywołamy sobie console.log dla naszego elementu header, podając własność style (console.log(header.style)), to w devtools w zakładce Console wyświetli nam się obiekt CSSStyleDeclaration, gdzie po rozwinięciu bedą widoczne wszystkie możliwe własności CSS, dostępne style, jakie możemy wykorzystać w danym elemencie. Możemy te własności modyfikować, przypisać za pomocą tego obiektu. Aby zmodyfikować kolor, podajemy tę własność z nową wartością, jaką chcemy nadać alementowi, np. header.style.color = 'red'. Jeśli podejrzymy sobie strukturę DOM w zakładce Elements w devtools, to widzimy, że JavaScript, wykonując skrypt po prostu dokłada zmieniający kolor styl inline przy nagłówku h1. W pliku HTML oczywiście nie będzie on widoczny. Wprowadza to duży bałagan do kodu. Trzymanie się poszczególnych wartsw strony i ich funkcji zapewnia nam przewidywalność zachowania naszej strony. Są jednak oczywiście przypadki, gdy takie modyfikacje mogą się nam przydać.
				</p>
				<img class="image" src="/css-style-declaration.jpg" alt="Wykonanie skryptu zmieniającego kolor nagłówka."/>
			</article>	
		</section>
		<section class="section">
			<h2 class="section__header">JavaScript - tydzień 5</h2>
			<article class="article">
				<h3 class="article__header">Funkcje</h3>
				<p class="article__paragraph">
					W matematyce jedną z prostszych funkcji jest funkacja liniowa, gdzie w nawiasie podajemy argument lub więcej arumentów oraz jej wynik.
				</p>
				<img class="image" src="/linear-function.jpg" alt="Wykres funkcji liniowej."/>
				<p class="article__paragraph">
					Mamy tu przykład najprostszej funkcji, składającej sie z nazwy f, argumentu w nawiasie i wyniku funkcji: f(x)=x, gdzie f(2)=2, etc. 
				</p>
				<img class="image" src="/function-definition.jpg" alt="Definicja funkcji liniowej."/>
				<p class="article__paragraph">
					Możemy tutaj wykonywać różne operacje, np. f(x)=x*7, gdzie argument x jest mnożony przez 7 i w efekcie mamy wynik f(1)=7, f(2)=14, etc.
				</p>
				<p class="article__paragraph">
					Funkcję w matematyce definiuje się w ten sposób, że funcja na wejściu dostaje dane, czyli argumenty i dla podanego argumentu zwraca jakąś wartość. Funkcja posiada określony wzór.
				</p>
				<p class="article__paragraph">
					Funkcję w JavaScript definiuje się natomiast w ten sposób, że zamiast f mamy słowo kluczowe function, następnie podajemy nazwę funkcji (tu: calculate), w nawiasie dajemy nazwę naszego argumentu (tu: myNumber), bez żadnego słowa kluczowego typu let czy const. Następnie za pomoca nawiasów klamrowych otwieramy ciało naszej funkcji, gdzie możemy opisać wiele rzeczy. Na koniec, jeśli funkcja ma coś zwracać, to dajemy słówko retur i to, co ma być zwrócone (tu: nasz argument myNumber pomnożony przez 7). Jest to odpowiednik matematycznego zapisu f(x)=x*7.
				</p>
				<p class="article__paragraph">
					Opisując funkcję w JavaScript językiem bardziej programistycznym, mamy deklarację, czyli słowo kluczowe function, następnie mamy parametr, czyli argument oraz słowo kluczowe return i wynik.
				</p>
				<img class="image" src="/function-js.jpg" alt="Definicja funkcji w JavaScript."/>
				<p class="article__paragraph">
					Nazwę funkcji najlepiej zapisać za pomocą camelCase.
				</p>
				<p class="article__paragraph">
					Jeśli stworzymy sobie funkcję zgodnie z powyższym przykładem i nasz parametr myNumber powiążemy z wartością 2, na którym wykonamy operację mnożenia razy 7, to po wywołaniu funkcji za pomocą console.log, otrzymamy w devtools wynik 14.
				</p>
				<img class="image" src="/function-example1.jpg" alt="Przykład zastosowania funkcji z parametrem myNumber o wartości 2."/>
				<p class="article__paragraph">
					Słowo kluczowe może wystąpić, ale nie musi, bo nie każda funkcja musi nam coś zwracać. Jeśli nie zdefiniujemy sobie za pomocą return, co dana funkcja ma zwrócić, to dostaniemy po prostu undefined.
				</p>
				<p class="article__paragraph">
					W ciele funkcji możemy zrobić wiele rzeczy, nie musi nam od razu czegoś zwracać. Możemy wykonywać np. obliczenia, modyfikacje napisów, wywołania innych funkcji etc. Na przykładzie poniżej mamy wywołanie za pomocą console.log funkcji myNumber wewnątrz ciała funkcji oraz zmianę przypisania wartości z myNumber na myNumber plus 3.
				</p>
				<img class="image" src="/function-example2.jpg" alt="Przykład zapisu funkcji z większą ilością operacji."/>
				<p class="article__paragraph">
					Funkcję możemy wywołać również bez użycia console.log, wywołując ją po prostu z określoną wartością przypisaną do jej argumentu. Na poniższym przykładzie wywołując funkcję calculate z przypisaną do argumentu wartością 1 otrzymujemy wynik 4. W devtools widać, że odnosimy się tutaj do linii 17 w pliku, gdzie następuje wywołąnie funkcji za pomocą console.log. Ostatnia linia ciała funkcji, w której stosujemy słowo return, nie zostaje nigdzie użyta, dlatego zapis ten nie wpływa na otrzymany wynik.
				</p>
				<img class="image" src="/function-example3.jpg" alt="Przykład bezpośredniego wywołania funkcji calculate z przypisaną wartością 1."/>
				<p class="article__paragraph">
					Wartość z linii 18 możemy jednak przypisać do zmiennej. Tworzymy zmienną result, do której przypisujemy wartość funkcji caluculate(1). Po wywołaniu zmiennej za pomocą console.log otrzymujemy wynik 28 (do funcji calcultae przypisujemy argument 1, który następnie zwiększamy o 3, a później po jego wywołaniu mnożymy przez 7). W devtools widać, że dwukrotnie otrzymujemy wynik 4. Dzieje się tak dlatego, że funkcja została wywołana zarówno w linii 21, poprzez samo jej wywołanie bez przypisywania nigdzie tego wyniku, jak i następnie w momencie przypisania funkcji calculate z argumentem 1 do zmiennej result.
				</p>
				<img class="image" src="/function-example4.jpg" alt="Przykład przypisania funkcji calculate z wartością 1 do zmiennej result."/>
				<p class="article__paragraph">
					Jeśli do zmiennej result przypiszemy funkcję calculate z argumentem 2, a następnie ją wywołamy, to po wykonaniu otrzymamy wynik 35 (do funcji calcultae przypisujemy argument 2, który następnie zwiększamy o 3, a później po jego wywołaniu mnożymy przez 7). W devtools widać, że funkcja zostaje najpierw wykonana z argumentem z przyisamą wartością 1 w linii 21, a następmnie w momencie jej przypisania do zmiennej result z argumentem o wartości 2 w linii 23.
				</p>
				<img class="image" src="/function-example4.jpg" alt="Przykład przypisania funkcji calculate z wartością 2 do zmiennej result."/>
				<p class="article__paragraph">
					Wracając do porównania funkcji w JavaScript do funkcji matematycznej, możemy podsumować, że: 
				</p>
				<ol class="ordered-list">
					<li class="ordered-list__element">Deklarujemy nazwę funkcji (nie zawsze).</li>
					<li class="ordered-list__element">W środku dokonujemy obliczeń lub wykonujemy zadania.</li>
					<li class="ordered-list__element">Funkcja przyjmuje argumenty (nie musi).</li>
					<li class="ordered-list__element">Funkcja zawsze coś zwraca. Jeśli nie mamy słowa kluczowego return, to wówczas zwraca undefined.</li>
				</ol>
				<p class="article__paragraph">
					Przykładem funkcji bez argumentu może być poniższa funkcja hello, która wywołuje po prostu inną funkcję, wypisującą po prostu "hello" w konsoli w devtools. Jeśłi następnie wywołamy sobie po prostu tę funkcję wpisując jej nazwę, to wykona się i w devtools dostaniemy jako wynik jej wykonania napis hello w konsoli. Wykonują się wtedy te operacje, które są w środku w ciele funkcji hello. Jeśli znajdzie sie tam kilkukrotne wywołanie funkcji console.log, to po wywołaniu funcji hello, wykonają sie wszystkie operacje w niej zawarte. Nie ma return, więc funkcja nic tutaj nie zwraca - jest po prostu skrótem do uruchomienia wielu operacji, które się w niej znajdują.
				</p>
				<img class="image" src="/function-example6.jpg" alt="Przykład zastosowania funkcji bez argumentu."/>
				<p class="article__paragraph">
					Posługując sie dalej tym przykładem, jeśli następnie wywołamy sobie funkcję hello za pomocą console.log, to otrzymamy jako wynik undefined, jako że sama funkcja nic nie zwraca, nie posiada słowa kluczowego return. Mimo tego, że funkcja nic nie zwraca, jako że nie posiada return, to w momencie wywołania jej za pomocą console.log, wykonają się również wszystkie operacje, które są w niej zawarte. 
				</p>
				<img class="image" src="/function-example7.jpg" alt="Wywołanie za pomocą console.log funkcji nie zawierającej słowa kluczowego return."/>
				<p class="article__paragraph">
					Przyczyny powstania funkcji:
				</p>
				<ol class="ordered-list">
					<li class="ordered-list__element">Deklaracja/opakowanie w funkcję kodu, który sie powtarza (DRY - don't repeat yourself).</li>
					<li class="ordered-list__element">Zwiększenie czytelności kodu.</li>
					<li class="ordered-list__element">Ułatwienie wyszukiwania błędów.</li>
					<li class="ordered-list__element">Odpowiedzialność za wykonywanie zadania w jednym miejscu.</li>
				</ol>
				<p class="article__paragraph">
					(Fat) arrow functions =>
				</p>
				<p class="article__paragraph">
					(Fat) arrow functions zostały wprowadzone w ECMAScript 6. Funkcja strzałkowa jest to trochę inny sposób definiowania funkcji. Zamiast korzystać ze słowa kluczowego function, podpisujemy funkcję pod jakąś zmienną, w naszym przykładzie jest to zmienna o nazwie calculate dla której po znaku równości w nawiasie podajemy argumenty i następnie używamy strzałki, po której otwieramy nawias klamrowy, w którym ciało funkcji wygląda już tak samo jak przy definiowaniu funkcji za pomocą słowa kluczowego function.
				</p>
				<img class="image" src="/arrow-function.jpg" alt="Sposób definiowania arrow function."/>
				<p class="article__paragraph">
					Istnieją różnice w działaniu tych funkcji, ale na tym etapie działają one dla nas identycznie.
				</p>
				<img class="image" src="/arrow-function-example.jpg" alt="Przykład zastowania funkcji strzałkowej."/>
				<p class="article__paragraph">
					Plusem arrow functions jest to, że mają trochę skróconą formę zapisu. Jeśli mamy podany tylko jeden argument dla funkcji, w naszym przypadku myNumber, to nie musimy podawać go w nawiasie. Ponadto jeśli w ciele funkcji mamy tylko prostą operację, którą można zapisać w jednej linii, to nie musimy umieszczać jej w ciele funkcji w nawiasach klamrowych. Zamiast tego po strzałce możemy umieścić jednolinijkowy zwrot, tak jakbyśmy podawali return. Samego słowa kluczowego return nie musimy jednak w tym przypadku podawać, będzie ono zastosowane domyślnie.
				</p>
				<img class="image" src="/arrow-function-short.jpg" alt="Skrócony zapis funkcji strzałkowej."/>
				<p class="article__paragraph">
					Po zapisaniu naszej dotychczasowej funkcji w formie skróconej, otzrymujemy prawie dokładnie to samo co wcześniej - z wyjątkiem console.log, ale on nie jest nam potrzebny do liczenia funkcji, pozwala tylko na podejrzenie, co aktualnie znajduje się w środku funkcji.
				</p>
				<img class="image" src="/arrow-function-short-example.jpg" alt="Przykład zastowania funkcji strzałkowej w skróconej formie zapisu."/>
				<p class="article__paragraph">
					Cechy (fat) arrow function:
				</p>
				<ol class="ordered-list">
					<li class="ordered-list__element">Skraca zapis deklaracji funkcji.</li>
					<li class="ordered-list__element">Zwiększenie czytelność (dyskusyjne).</li>
					<li class="ordered-list__element">Nie tworzy nowego kontekstu this, nie ma dostępu do arguments i super.</li>
					<li class="ordered-list__element">Nie stanowi zamiennika tradycyjnej funkcji, ale w większości przypadków nie będzie widać różnicy w ich zastosowaniu (jeśłi nie będzie się korzystać z opcji z punktu 3).</li>
				</ol>
				<p class="article__paragraph">
					Warto w projekcie trzymać się jednego sposobu zapisu funkcji.
				</p>
			</article>
			<article class="article">
				<h3 class="article__header">Obiekty w JS</h3>
				<p class="article__paragraph">
					Prawie wszystko w JavaScript jest obiektem, bo nawet typy proste, mimo, że nie są obiektem, to się tak zachowują. Obiekt jest strukturą danych, sposobem opisu danych. Nie jest to typ prosty. JavaScript, podobnie jak świat, jest obiektowy. Znajdują się w nim obiekty, które możemy opisać za pomocą pewnych własności i które mogą czasem wykonywać jakieś akcje.
				</p>
				<p class="article__paragraph">
					W strukturze danych wykorzystywanych do opisu obiektów, w obiektach, które tworzymy, używamy zapisu składającego się z nawiasów sześciennych i par składających się z klucza i wartości. Każdą taką parę kończymy przecinkiem, dzięki czemu wiemy, gdzie dana para zaczyna się i kończy. Przecinek po ostatniej parze klucz-wartość nie jest konieczny, ale nie jest też błędem.
				</p>
				<img class="image" src="/object-example.jpg" alt="Przykład zastowania par klucz-wartość do opisu obiektu."/>
				<p class="article__paragraph">
					Klucz musi być unikalny w ramach obiektu. Jako wartość natomiast możemy podać prymitywy, funkcje lub kolejne, zagnieżdżone obiekty.
				</p>
				<p class="article__paragraph">
					W świecie obiektowym używamy innych nazw na rzeczy - nie są to zmienne, lecz własności (property). W naszym przykładzie gwiazdy śmierci, własnościami będą klucze, czyli np. średnica (diameter). Podobnie ma się to w przypadku funkcji, w świecie obiektowym nie są to funkcje, lecz metody (methods). Mimo, że wyglądają tak samo i zachowują sie podobnie to nie są to zmienne czy funkcje, tylko własności i metody.
				</p>
				<p class="article__paragraph">
					Po wywołaniu obiektu w kodzie, w konsoli w devtools wyświetlą się informacje o tym obiekcie w parach klucz-wartość. W devtools wyświetla się też pod spodem sekcja prototype doklejona do naszgo obiektu, ale na tym etapie nie będziemy się zajmować prototypami.
				</p>
				<img class="image" src="/object-devtools.jpg" alt="Wywołanie obiektu w kodzie i jego podgląd w devtools."/>
				<p class="article__paragraph">
					Aby dostać się do konkretnej własności naszego obiektu, stosujemy dot notation, z której korzystaliśmy już w funkcji console.log. Jest to odnoszenie się do czegoś poprzez kropkę. Przykładowo, żeby dostać się do średnicy naszego obiektu, wpisujey deathStar.diameter.
				</p>
				<img class="image" src="/dot-notation.jpg" alt="Wywołanie konkretnej własności obiektu za pomocą dot notation."/>
				<p class="article__paragraph">
					Aby wywołać daną metodę zdefiniowaną w ramach obiektu, wpisujemy nazwę obiektu i po kropce nazwę metody. Do metody przekazujemy parametr, na naszym przykładzie jest to cel (target), jako który możemy wpisać sobie string 'alderaan': deathStar.fire('alderaan'). Metodę można wywołąć dowolną ilość razy z różnymi parametrami.
				</p>
				<img class="image" src="/object-method.jpg" alt="Wywołanie konkretnej metody dla obiektu."/>
				<p class="article__paragraph">
					Drugim sposobem dostania się do własności obiektu jest bracket notation, czyli zapis z nawiasami kwadratowymi []. Zamiast podawania kropki, opakowujemy nasze własności w nawiasy kwadratowe. Własności zapisujemy w apostrofach. Czyli zamiast deathStar.diameter będziemy mieć deathStar['diameter'].
				</p>
				<img class="image" src="/bracket-notation.jpg" alt="Wywołanie konkretnej własności obiektu za pomocą bracket notation."/>
				<p class="article__paragraph">
					Jak już było wcześniej wspomniane, w obiekcie mogą być zagnieżdżone inne obiekty. Może zdarzyć się, że klucz w ramach zagnieżdżonego obiektu będzie miał taką samą nazwę jak klucz znajdujący się bezpośrednio w tym obiekcie, w którym znajduje się zagnieżdżony obiekt. Jest to jednak zgodne z zasadą unikalności, bo dotyczy ona tylko danego konretnego obiektu, a w takim przypadku nazwy kluczy będą dotyczyć różnych poziomów. Aby dostać się do własności takiego zagnieżdżonego obiektu, dodajemy kolejną krpkę w zapisie, przechodząc do kolejnego poziomu zagnieżdżenia. Na naszym przykładzie będzie to deathStar.commander.name, gdzie wywołujemy własność name obiektu commander, który jest zagnieżdżony w obiekcie deathStar.
				</p>
				<img class="image" src="/nested-object.jpg" alt="Wywołanie konkretnej własności obiektu zagnieżdżonego w innym obiekcie."/>
			</article>
			<article class="article">
				<h3 class="article__header">Immutability (niemutowalność) w obiektach</h3>
				<p class="article__paragraph">
					We wcześniejszych lekcjach było powiedziane, że immutability oznacza, że nie możemy zmieniać wartości primitive values w JavaScript. To, co zmieniamy, to połączenia między tymi wartościami a zmiennymi. Na poniższym przykładzie mamy definicje 4 zmiennych: dwie liczby i dwa stringi w postaci imion, przy czym jedno z imion jest zdefiniowane za pomocą let, co oznacza, że można zmienić wskazanie zmiennej, podmienić połączenie do wartości, natomiast pozostałe zmienne są zdefiniowane za pomocą słowa kluczowego const.
				</p>
				<img class="image" src="/variables-definition-example3.jpg" alt="Definicja zmiennych za pomocą const i let."/>
				<p class="article__paragraph">
					Obie zmienne liczbowe wskazują na tę samą wartość, 42 - nie mamy tu dwóch wartości 42 lecz jedną, na którą wskazują obie zmienne. Połączenie z imieniem Stefan jest natomiast zdefiniowane za pomocą słowa kluczowego let, a zatem możemy je zmienić i połączyć zmienną z imieniem Maciek. Nie oznacza to, że powstaną dwie wartości Maciek - nadal jest jedna, tylko wskazują na nią dwie zmienne. Stefan nadal istnieje w świecie wartości, ale nie jest połączony z żadną z naszych zmiennych.
				</p>
				<img class="image" src="/variables-definition-example4.jpg" alt="Przedstawienie połączeń między zmiennymi na schemacie."/>
				<img class="image" src="/variables-definition-example5.jpg" alt="Zmiana przypisania zmiennej do wartości."/>
				<img class="image" src="/variables-definition-example6.jpg" alt="Przedstawienie zmiany połączenia zmiennej z wartością na schemacie."/>
			</article>
			<p class="article__paragraph">
				Przenosząc ten przykład na obiekty, mamy dwie zmienne humanOne i humanTwo, które wskazują na obiekt, który ma takie własności jak name i age, wskazujące na konretne wartości. Różnica w stosunku do poprzedniego przykładu jest taka, że połączenia między własnościami i wartościami nie są stałe, można je zmieniać (na wcześniejszym przykładzie można było zmienić tylko przypisanie zmiennej zdefiniowanej za pomocą słowa kluczowego let). Własności nie mają takich sztywnych ram jak zmienne.
			</p>
			<img class="image" src="/object-variable-example1.jpg" alt="Definicja zmiennych i obiektów."/>
			<img class="image" src="/object-variable-example2.jpg" alt="Przedstawienie połączeń między zmiennymi, obiektami i wartościami za pomocą grafu."/>
			<img class="image" src="/object-variable-example3.jpg" alt="Zmiana własności age dla jednego z obiektów."/>
		</section>
	</main>
    <footer class="footer">
		<p class="footer__content">Strona domowa Magdaleny Derek, wszystkie treści są wynikiem nauki w ramach szkolenia WTF: Co
			ten frontend. 
			<a class="footer__top-link" href="#top">Wróć na górę strony ⬆️</a>
		</p>
		</footer>
	<script defer src="/main.js"></script>
</body>

</html>